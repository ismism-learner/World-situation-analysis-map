<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D çƒå½¢åœ°çƒè§‚å¯Ÿå™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/shapefile@0.6.6/dist/shapefile.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a14 100%);
            color: #eee;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(135deg, #16213e 0%, #0f1926 100%);
            padding: 15px 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 10;
            backdrop-filter: blur(10px);
            transform: translateY(-80%);
            transition: transform 0.3s ease-in-out;
        }

        #header.header-expanded,
        #header:hover {
            transform: translateY(0);
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
        
        #controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
            color: #0a0a14;
            padding: 10px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }
        
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
        }
        
        button {
            background: rgba(15, 52, 96, 0.8);
            color: #00d4ff;
            border: 2px solid #00d4ff;
            padding: 8px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        button:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }
        
        #info {
            color: #88ddff;
            font-size: 13px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        #map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #globe-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        svg {
            width: 100%;
            height: 100%;
        }
        
        .sphere {
            fill: url(#ocean-gradient);
        }
        
        .country {
            fill: #1e3a5f;
            stroke: #00d4ff;
            stroke-width: 0.5;
            transition: all 0.3s;
        }
        
        .country:hover {
            fill: #2d5a8f;
            stroke: #00ffff;
            stroke-width: 1.5;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.8));
            cursor: pointer;
        }
        
        .country.selected {
            fill: #ff6b35;
            stroke: #ffaa00;
            stroke-width: 2;
        }
        
        .connection-arc {
            fill: none;
            stroke: #00ffff;
            opacity: 0.6;
            filter: drop-shadow(0 0 8px rgba(0, 255, 255, 0.8));
            pointer-events: none;
        }
        
        .connection-point {
            fill: #ff6b35;
            stroke: #ffaa00;
            stroke-width: 2;
            filter: drop-shadow(0 0 10px rgba(255, 107, 53, 0.8));
        }
        
        .graticule {
            fill: none;
            stroke: rgba(0, 212, 255, 0.2);
            stroke-width: 0.5;
        }
        
        #tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.95) 0%, rgba(0, 150, 255, 0.95) 100%);
            color: #0a0a14;
            padding: 10px 16px;
            border-radius: 8px;
            pointer-events: none;
            display: none;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        #legend {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(22, 33, 62, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #00d4ff;
            font-size: 13px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .legend-title {
            font-weight: bold;
            margin-bottom: 12px;
            color: #00d4ff;
            font-size: 15px;
            text-shadow: 0 2px 4px rgba(0, 212, 255, 0.5);
        }
        
        .legend-item {
            margin: 8px 0;
            color: #88ddff;
        }
        
        #rotation-info {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(22, 33, 62, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid #00d4ff;
            font-size: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            color: #88ddff;
            font-family: 'Courier New', monospace;
        }
        
        #debug-info {
            position: absolute;
            top: 120px;
            right: 30px;
            background: rgba(22, 33, 62, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid #ff8800;
            font-size: 11px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            color: #ffaa44;
            font-family: 'Courier New', monospace;
            max-width: 300px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff88;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>ğŸŒ 3D çƒå½¢åœ°çƒè§‚å¯Ÿå™¨</h1>
            <div id="controls">
                <div class="file-input-wrapper">
                    <label for="fileInputBundle" class="file-input-label">ğŸ“¦ åŠ è½½åœ°å›¾åŒ…ï¼ˆZIPï¼‰</label>
                    <input type="file" id="fileInputBundle" accept=".zip" />
                </div>
                <div style="margin-left: 10px; color: #88ddff; font-size: 12px;">
                    æˆ–å•ç‹¬åŠ è½½ï¼š
                </div>
                <div class="file-input-wrapper">
                    <label for="fileInput110m" class="file-input-label" style="font-size: 12px; padding: 6px 12px;">1:110m</label>
                    <input type="file" id="fileInput110m" accept=".geojson,.json,.shp,.zip" multiple />
                </div>
                <div class="file-input-wrapper">
                    <label for="fileInput50m" class="file-input-label" style="font-size: 12px; padding: 6px 12px;">1:50m</label>
                    <input type="file" id="fileInput50m" accept=".geojson,.json,.shp,.zip" multiple />
                </div>
                <div class="file-input-wrapper">
                    <label for="fileInput10m" class="file-input-label" style="font-size: 12px; padding: 6px 12px;">1:10m</label>
                    <input type="file" id="fileInput10m" accept=".geojson,.json,.shp,.zip" multiple />
                </div>
                <button id="resetBtn">ğŸ”„ é‡ç½®è§†å›¾</button>
                <button id="toggleGraticule">ğŸŒ åˆ‡æ¢ç»çº¬ç½‘</button>
                <button id="toggleRotation">â–¶ï¸ å¼€å§‹æ—‹è½¬</button>
                <button id="clearConnections">ğŸ—‘ï¸ æ¸…é™¤è¿æ¥çº¿</button>
                <div style="display: flex; align-items: center; gap: 10px; color: #88ddff;">
                    <label for="lineWidthSlider">çº¿å®½:</label>
                    <input type="range" id="lineWidthSlider" min="1" max="20" value="2.5" step="0.5" style="cursor: pointer;">
                    <span id="lineWidthValue">2.5px</span>
                </div>
                <span id="info">è¯·åŠ è½½åœ°å›¾åŒ…æˆ–å•ç‹¬åŠ è½½å„çº§åˆ«åœ°å›¾</span>
            </div>
        </div>
        
        <div id="map-container">
            <div id="globe-container">
                <svg id="globe"></svg>
            </div>
            <div id="tooltip"></div>
            <div id="legend">
                <div class="legend-title">ğŸ® æ“ä½œè¯´æ˜</div>
                <div class="legend-item">ğŸ–±ï¸ æ‹–æ‹½: æ—‹è½¬åœ°çƒï¼ˆä»»æ„æ–¹å‘ï¼‰</div>
                <div class="legend-item">ğŸ–±ï¸ æ»šè½®: ç¼©æ”¾è§†å›¾</div>
                <div class="legend-item">ğŸ–±ï¸ æ‚¬åœ: æŸ¥çœ‹å›½å®¶</div>
                <div class="legend-item">ğŸ‘† ç‚¹å‡»: é€‰æ‹©ä¸¤ä¸ªåœ°ç‚¹è¿çº¿</div>
                <div class="legend-item">â¸ï¸ æŒ‰é’®: æ§åˆ¶è‡ªåŠ¨æ—‹è½¬</div>
            </div>
            <div id="rotation-info">
                <span class="status-indicator"></span>
                <span id="rotation-status">æ—‹è½¬å·²æš‚åœ</span>
            </div>
            <div id="debug-info">
                <div><strong>ğŸ” è°ƒè¯•ä¿¡æ¯</strong></div>
                <div>ç»åº¦: <span id="debug-lon">0Â°</span></div>
                <div>çº¬åº¦: <span id="debug-lat">0Â°</span></div>
                <div>ç¼©æ”¾: <span id="debug-zoom">1.0x</span></div>
                <div>å½“å‰åœ°å›¾: <span id="debug-lod">æœªåŠ è½½</span></div>
                <div>å¯è§å›½å®¶: <span id="debug-visible">0</span></div>
                <div>æ€»å›½å®¶æ•°: <span id="debug-total">0</span></div>
                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ffaa44;">
                    <strong>ğŸ“ è¿æ¥çº¿æ¨¡å¼</strong><br>
                    <span id="connection-mode">å¾…é€‰æ‹©èµ·ç‚¹</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const svg = d3.select("#globe");
        const globeContainer = document.getElementById('globe-container');
        let width, height, initialScale;

        // åˆ›å»ºæ¸å˜
        const defs = svg.append("defs");
        const oceanGradient = defs.append("radialGradient")
            .attr("id", "ocean-gradient");
        oceanGradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", "#1a3d5c");
        oceanGradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", "#0a1929");
        
        const projection = d3.geoOrthographic()
            .rotate([0, 0, 0])
            .clipAngle(90);
        
        const path = d3.geoPath().projection(projection);
        const graticule = d3.geoGraticule();
        
        // ç»˜åˆ¶çƒä½“
        svg.append("path")
            .datum({type: "Sphere"})
            .attr("class", "sphere")
            .attr("d", path);
        
        const g = svg.append("g");
        const connectionsGroup = svg.append("g").attr("class", "connections");
        
        // ç»˜åˆ¶ç»çº¬ç½‘
        let graticulePath = g.append("path")
            .datum(graticule)
            .attr("class", "graticule")
            .attr("d", path);
        
        let showGraticule = true;
        let isRotating = false;
        let rotation = [0, 0];
        
        let currentGeoJSON = null;
        let selectedPoints = [];
        let connections = [];
        
        // LOD ç³»ç»Ÿï¼šå­˜å‚¨ä¸åŒç²¾åº¦çš„åœ°å›¾
        let mapLOD = {
            '110m': null,  // æœ€ç²—ç³™ï¼Œç¼©æ”¾ 0.5 - 1.5
            '50m': null,   // ä¸­ç­‰ï¼Œç¼©æ”¾ 1.5 - 3.0
            '10m': null    // æœ€ç²¾ç»†ï¼Œç¼©æ”¾ 3.0+
        };
        let currentLOD = null;
        
        // æ ¹æ®ç¼©æ”¾çº§åˆ«åˆ‡æ¢åœ°å›¾
        function switchLOD(zoomLevel) {
            let targetLOD = null;
            
            if (zoomLevel < 1.5) {
                targetLOD = '110m';
            } else if (zoomLevel < 3.0) {
                targetLOD = '50m';
            } else {
                targetLOD = '10m';
            }
            
            // å¦‚æœç›®æ ‡ LOD æ²¡æœ‰åŠ è½½ï¼Œä½¿ç”¨å·²åŠ è½½çš„æœ€æ¥è¿‘çš„
            if (!mapLOD[targetLOD]) {
                if (targetLOD === '110m') {
                    targetLOD = mapLOD['50m'] ? '50m' : (mapLOD['10m'] ? '10m' : null);
                } else if (targetLOD === '50m') {
                    targetLOD = mapLOD['110m'] ? '110m' : (mapLOD['10m'] ? '10m' : null);
                } else if (targetLOD === '10m') {
                    targetLOD = mapLOD['50m'] ? '50m' : (mapLOD['110m'] ? '110m' : null);
                }
            }
            
            // å¦‚æœéœ€è¦åˆ‡æ¢
            if (targetLOD && targetLOD !== currentLOD && mapLOD[targetLOD]) {
                console.log(`åˆ‡æ¢åˆ° ${targetLOD} åœ°å›¾ (ç¼©æ”¾: ${zoomLevel.toFixed(2)})`);
                currentLOD = targetLOD;
                currentGeoJSON = mapLOD[targetLOD];
                renderCurrentMap();
                document.getElementById('debug-lod').textContent = targetLOD;
            }
        }
        
        // æ¸²æŸ“å½“å‰åœ°å›¾
        function renderCurrentMap() {
            if (!currentGeoJSON) return;
            
            g.selectAll(".country").remove();
            
            g.selectAll(".country")
                .data(currentGeoJSON.features)
                .enter()
                .append("path")
                .attr("class", "country")
                .attr("d", path)
                .on("click", function(event, d) {
                    event.stopPropagation();
                    
                    const centroid = d3.geoCentroid(d);
                    
                    if (selectedPoints.length === 0) {
                        selectedPoints.push(centroid);
                        d3.select(this).classed("selected", true);
                        updateConnectionMode();
                        
                        const name = d.properties.NAME || d.properties.name || 
                                   d.properties.ADMIN || d.properties.admin || "æœªçŸ¥";
                        document.getElementById("info").textContent = `âœ… å·²é€‰æ‹©èµ·ç‚¹: ${name}`;
                    } else if (selectedPoints.length === 1) {
                        selectedPoints.push(centroid);
                        
                        const name = d.properties.NAME || d.properties.name || 
                                   d.properties.ADMIN || d.properties.admin || "æœªçŸ¥";
                        document.getElementById("info").textContent = `âœ… å·²åˆ›å»ºè¿æ¥çº¿åˆ°: ${name}`;
                        
                        drawConnection(selectedPoints[0], selectedPoints[1]);
                        
                        selectedPoints = [];
                        g.selectAll(".country").classed("selected", false);
                        updateConnectionMode();
                    }
                })
                .on("mouseover", function(event, d) {
                    const name = d.properties.NAME || d.properties.name || 
                               d.properties.ADMIN || d.properties.admin || 
                               d.properties.NAME_LONG || d.properties.NAME_EN || 
                               d.properties.COUNTRY || "æœªçŸ¥";
                    tooltip
                        .style("display", "block")
                        .html(name);
                })
                .on("mousemove", function(event) {
                    tooltip
                        .style("left", (event.pageX + 15) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("display", "none");
                });
        }
        
        // æ›´æ–°è¿æ¥çº¿çŠ¶æ€æ˜¾ç¤º
        function updateConnectionMode() {
            const modeText = document.getElementById('connection-mode');
            if (selectedPoints.length === 0) {
                modeText.textContent = 'å¾…é€‰æ‹©èµ·ç‚¹';
                modeText.style.color = '#ffaa44';
            } else if (selectedPoints.length === 1) {
                modeText.textContent = 'å·²é€‰èµ·ç‚¹ï¼Œé€‰æ‹©ç»ˆç‚¹';
                modeText.style.color = '#00ff88';
            }
        }
        
        // ç»˜åˆ¶è¿æ¥çº¿
        function drawConnection(point1, point2) {
            // ä½¿ç”¨ D3 çš„çƒé¢æ’å€¼åˆ›å»ºå¤§åœ†å¼§
            const interpolate = d3.geoInterpolate(point1, point2);
            
            // ç”Ÿæˆå¼§çº¿ä¸Šçš„ç‚¹
            const points = [];
            for (let i = 0; i <= 100; i++) {
                points.push(interpolate(i / 100));
            }
            
            // åˆ›å»º LineString
            const arcLine = {
                type: "LineString",
                coordinates: points
            };
            
            const currentLineWidth = document.getElementById("lineWidthSlider").value;

            // ç»˜åˆ¶å¼§çº¿
            connectionsGroup.append("path")
                .datum(arcLine)
                .attr("class", "connection-arc")
                .attr("d", path)
                .style("stroke-width", `${currentLineWidth}px`);
            
            // ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹æ ‡è®°
            const center = [-projection.rotate()[0], -projection.rotate()[1]];

            const isVisible1 = d3.geoDistance(point1, center) < Math.PI / 2;
            const p1 = projection(point1);
            connectionsGroup.append("circle")
                .datum({type: "Point", coordinates: point1})
                .attr("class", "connection-point")
                .attr("cx", p1 ? p1[0] : -999)
                .attr("cy", p1 ? p1[1] : -999)
                .attr("r", 5)
                .style("display", isVisible1 ? "block" : "none");

            const isVisible2 = d3.geoDistance(point2, center) < Math.PI / 2;
            const p2 = projection(point2);
            connectionsGroup.append("circle")
                .datum({type: "Point", coordinates: point2})
                .attr("class", "connection-point")
                .attr("cx", p2 ? p2[0] : -999)
                .attr("cy", p2 ? p2[1] : -999)
                .attr("r", 5)
                .style("display", isVisible2 ? "block" : "none");
            
            // ä¿å­˜è¿æ¥
            connections.push({point1, point2, arcLine});
        }
        
        // æ›´æ–°æ‰€æœ‰è¿æ¥çº¿çš„ä½ç½®
        function updateConnections() {
            connectionsGroup.selectAll("path").attr("d", path);
            
            const center = [-projection.rotate()[0], -projection.rotate()[1]];
            
            connectionsGroup.selectAll("circle")
                .each(function(d) {
                    const circle = d3.select(this);
                    const isVisible = d3.geoDistance(d.coordinates, center) < Math.PI / 2;
                    
                    if (isVisible) {
                        const p = projection(d.coordinates);
                        circle.attr("cx", p[0])
                              .attr("cy", p[1])
                              .style("display", "block");
                    } else {
                        circle.style("display", "none");
                    }
                });
        }
        
        // æ¸…é™¤æ‰€æœ‰è¿æ¥çº¿
        function clearConnections() {
            connectionsGroup.selectAll("*").remove();
            connections = [];
            selectedPoints = [];
            g.selectAll(".country").classed("selected", false);
            updateConnectionMode();
        }
        
        // æ›´æ–°è°ƒè¯•ä¿¡æ¯
        function updateDebugInfo() {
            const rotate = projection.rotate();
            document.getElementById('debug-lon').textContent = rotate[0].toFixed(1) + 'Â°';
            document.getElementById('debug-lat').textContent = rotate[1].toFixed(1) + 'Â°';
            
            if (initialScale) {
                const scale = projection.scale() / initialScale;
                document.getElementById('debug-zoom').textContent = scale.toFixed(2) + 'x';
            }
            
            if (currentGeoJSON) {
                const visible = g.selectAll('.country').nodes().filter(node => {
                    const display = d3.select(node).style('display');
                    const visibility = d3.select(node).style('visibility');
                    return display !== 'none' && visibility !== 'hidden';
                }).length;
                
                document.getElementById('debug-visible').textContent = visible;
                document.getElementById('debug-total').textContent = currentGeoJSON.features.length;
            }
            
            // æ›´æ–°è¿æ¥çº¿ä½ç½®
            updateConnections();
        }
        
        // è‡ªåŠ¨æ—‹è½¬
        const rotationSpeed = 0.3;
        let rotationTimer = d3.timer(function(elapsed) {
            if (isRotating) {
                rotation[0] = (rotation[0] + rotationSpeed) % 360;
                projection.rotate(rotation);
                svg.selectAll(".sphere, .country, .graticule").attr("d", path);
                updateDebugInfo();
            }
        });
        
        // æ‹–æ‹½æ—‹è½¬ - æ¢å¤ä¸Šä¸‹å·¦å³æ—‹è½¬
        const drag = d3.drag()
            .on("start", function(event) {
                isRotating = false;
                updateRotationStatus();
            })
            .on("drag", function(event) {
                const rotate = projection.rotate();
                const k = 75 / projection.scale();
                // æ¢å¤å®Œæ•´çš„æ—‹è½¬ï¼šå·¦å³å’Œä¸Šä¸‹
                projection.rotate([
                    rotate[0] + event.dx * k,
                    rotate[1] - event.dy * k  // æ¢å¤çº¬åº¦æ—‹è½¬
                ]);
                rotation = projection.rotate();
                svg.selectAll(".sphere, .country, .graticule").attr("d", path);
                updateDebugInfo();
            });
        
        svg.call(drag);
        
        // ç¼©æ”¾
        const zoom = d3.zoom()
            .scaleExtent([0.5, 100])
            .on("zoom", function(event) {
                if (!initialScale) return;
                projection.scale(initialScale * event.transform.k);
                
                // æ ¹æ®ç¼©æ”¾çº§åˆ«åˆ‡æ¢åœ°å›¾
                switchLOD(event.transform.k);
                
                svg.selectAll(".sphere, .country, .graticule").attr("d", path);
                updateDebugInfo();
            });
        
        svg.call(zoom);
        
        const tooltip = d3.select("#tooltip");
        
        function renderGeoJSON(geojson) {
            console.log("æ¸²æŸ“åœ°å›¾æ•°æ®:", geojson);
            
            if (!geojson || !geojson.features || geojson.features.length === 0) {
                alert("åœ°å›¾æ•°æ®ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®");
                document.getElementById("info").textContent = "âŒ åœ°å›¾æ•°æ®æ— æ•ˆ";
                return;
            }
            
            currentGeoJSON = geojson;
            renderCurrentMap();
            
            console.log("å·²æ¸²æŸ“", geojson.features.length, "ä¸ªè¦ç´ ");
            document.getElementById("info").textContent = 
                `âœ… å·²åŠ è½½åœ°å›¾ (${geojson.features.length} ä¸ªåœ°ç†è¦ç´ )`;
            
            // åˆå§‹åŒ–è°ƒè¯•ä¿¡æ¯
            updateDebugInfo();
        }
        
        function renderGeoJSONToLOD(geojson, lodLevel) {
            console.log(`åŠ è½½ ${lodLevel} åœ°å›¾:`, geojson);
            
            if (!geojson || !geojson.features || geojson.features.length === 0) {
                alert("åœ°å›¾æ•°æ®ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®");
                return;
            }
            
            mapLOD[lodLevel] = geojson;
            
            // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡åŠ è½½ï¼Œæˆ–è€…å½“å‰æ²¡æœ‰åœ°å›¾ï¼Œä½¿ç”¨è¿™ä¸ª
            if (!currentGeoJSON) {
                currentLOD = lodLevel;
                currentGeoJSON = geojson;
                renderCurrentMap();
                document.getElementById('debug-lod').textContent = lodLevel;
            }
            
            console.log(`${lodLevel} åœ°å›¾å·²åŠ è½½ (${geojson.features.length} ä¸ªè¦ç´ )`);
            document.getElementById("info").textContent = 
                `âœ… ${lodLevel} åœ°å›¾å·²åŠ è½½ (${geojson.features.length} ä¸ªè¦ç´ )`;
            
            updateDebugInfo();
        }
        
        function loadGeoJSON(file, lodLevel) {
            document.getElementById("info").textContent = `â³ æ­£åœ¨åŠ è½½ ${lodLevel} GeoJSON...`;
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const geojson = JSON.parse(e.target.result);
                    console.log(`${lodLevel} GeoJSON è§£ææˆåŠŸ:`, geojson);
                    renderGeoJSONToLOD(geojson, lodLevel);
                } catch (error) {
                    console.error("GeoJSON è§£æé”™è¯¯:", error);
                    alert("GeoJSON æ–‡ä»¶è§£æå¤±è´¥: " + error.message);
                    document.getElementById("info").textContent = "âŒ åŠ è½½å¤±è´¥";
                }
            };
            
            reader.onerror = function() {
                alert("GeoJSON æ–‡ä»¶è¯»å–é”™è¯¯");
                document.getElementById("info").textContent = "âŒ æ–‡ä»¶è¯»å–é”™è¯¯";
            };
            
            reader.readAsText(file);
        }
        
        function loadShapefile(file, lodLevel) {
            document.getElementById("info").textContent = `â³ æ­£åœ¨åŠ è½½ ${lodLevel} Shapefile...`;
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    console.log(`å¼€å§‹è§£æ ${lodLevel} Shapefile, å¤§å°:`, arrayBuffer.byteLength);
                    
                    if (typeof shapefile === 'undefined') {
                        alert("Shapefile åº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•æˆ–ä½¿ç”¨ GeoJSON æ ¼å¼");
                        document.getElementById("info").textContent = "âŒ Shapefile åº“æœªåŠ è½½";
                        return;
                    }
                    
                    shapefile.open(arrayBuffer)
                        .then(source => {
                            const features = [];
                            
                            function readNext() {
                                return source.read().then(result => {
                                    if (result.done) {
                                        return features;
                                    }
                                    features.push(result.value);
                                    return readNext();
                                });
                            }
                            
                            return readNext();
                        })
                        .then(function(features) {
                            console.log(`è¯»å–åˆ° ${lodLevel}`, features.length, "ä¸ªè¦ç´ ");
                            const geojson = {
                                type: "FeatureCollection",
                                features: features
                            };
                            renderGeoJSONToLOD(geojson, lodLevel);
                        })
                        .catch(function(error) {
                            console.error("Shapefile è§£æé”™è¯¯:", error);
                            alert("Shapefile è§£æå¤±è´¥: " + error.message);
                            document.getElementById("info").textContent = "âŒ Shapefile åŠ è½½å¤±è´¥";
                        });
                } catch (error) {
                    console.error("è¯»å–æ–‡ä»¶é”™è¯¯:", error);
                    alert("è¯»å–æ–‡ä»¶å¤±è´¥: " + error.message);
                    document.getElementById("info").textContent = "âŒ æ–‡ä»¶è¯»å–å¤±è´¥";
                }
            };
            
            reader.onerror = function() {
                alert("æ–‡ä»¶è¯»å–é”™è¯¯");
                document.getElementById("info").textContent = "âŒ æ–‡ä»¶è¯»å–é”™è¯¯";
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        function parseAndLoadShapefile(zipBuffer, lodLevel, filenameHint) {
            return shapefile.open(zipBuffer)
                .then(source => {
                    const features = [];
                    function readNext() {
                        return source.read().then(result => {
                            if (result.done) return features;
                            features.push(result.value);
                            return readNext();
                        });
                    }
                    return readNext();
                })
                .then(features => {
                    const geojson = { type: "FeatureCollection", features: features };
                    renderGeoJSONToLOD(geojson, lodLevel);
                    return { lodLevel, features };
                })
                .catch(error => {
                    console.error(`åŠ è½½ ${lodLevel} åœ°å›¾ (${filenameHint}) å¤±è´¥:`, error);
                    alert(`åŠ è½½ ${lodLevel} åœ°å›¾ (${filenameHint}) å¤±è´¥: ${error.message}`);
                });
        }

        function loadZipFile(file, lodLevel) {
            document.getElementById("info").textContent = `â³ æ­£åœ¨åŠ è½½ ${lodLevel} ZIP æ–‡ä»¶...`;
            const reader = new FileReader();
            reader.onload = (e) => parseAndLoadShapefile(e.target.result, lodLevel, file.name);
            reader.onerror = () => {
                alert("æ–‡ä»¶è¯»å–é”™è¯¯");
                document.getElementById("info").textContent = "âŒ æ–‡ä»¶è¯»å–é”™è¯¯";
            };
            reader.readAsArrayBuffer(file);
        }
        
        // åŠ è½½åŒ…å«å¤šä¸ªç²¾åº¦åœ°å›¾çš„ZIPåŒ…
        function loadMapBundle(file) {
            document.getElementById("info").textContent = "â³ æ­£åœ¨è§£æåœ°å›¾åŒ…...";
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                
                if (typeof JSZip === 'undefined' || typeof shapefile === 'undefined') {
                    alert("æ‰€éœ€åº“ï¼ˆJSZip, Shapefileï¼‰æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚");
                    return;
                }
                
                JSZip.loadAsync(arrayBuffer).then(function(zip) {
                    const shpFiles = Object.keys(zip.files).filter(name => name.endsWith('.shp') && !zip.files[name].dir);
                    
                    if (shpFiles.length === 0) {
                        alert("åœ°å›¾åŒ…ä¸­æœªæ‰¾åˆ° .shp æ–‡ä»¶ã€‚");
                        document.getElementById("info").textContent = "âŒ æœªæ‰¾åˆ° Shapefile";
                        return;
                    }

                    document.getElementById("info").textContent = `â³ æ‰¾åˆ° ${shpFiles.length} ä¸ª Shapefileï¼Œå¼€å§‹åŠ è½½...`;
                    let loadedCount = 0;
                    
                    const loadPromises = shpFiles.map(shpFilename => {
                        const basename = shpFilename.replace(/\.shp$/, '');
                        const lodMatch = basename.match(/(\d+m)/);
                        
                        if (!lodMatch) {
                            console.warn(`æ— æ³•ä»æ–‡ä»¶å ${shpFilename} ä¸­è¯†åˆ«åˆ†è¾¨ç‡ï¼Œå·²è·³è¿‡ã€‚`);
                            return Promise.resolve(); // Skip this file
                        }
                        const lodLevel = lodMatch[1];
                        
                        const relatedFiles = Object.keys(zip.files).filter(name => name.startsWith(basename) && !zip.files[name].dir);
                        const subZip = new JSZip();
                        const filePromises = relatedFiles.map(filename => {
                            return zip.files[filename].async("arraybuffer").then(content => {
                                subZip.file(filename.split('/').pop(), content);
                            });
                        });
                        
                        return Promise.all(filePromises)
                            .then(() => subZip.generateAsync({type: "arraybuffer"}))
                            .then(subZipBuffer => parseAndLoadShapefile(subZipBuffer, lodLevel, shpFilename))
                            .then(result => {
                                if (result) {
                                    loadedCount++;
                                    document.getElementById("info").textContent = 
                                        `âœ… å·²åŠ è½½ ${loadedCount}/${shpFiles.length} ä¸ªåœ°å›¾ (${result.lodLevel}: ${result.features.length} è¦ç´ )`;
                                }
                            });
                    });

                    Promise.all(loadPromises).then(() => {
                        if (loadedCount > 0) {
                             document.getElementById("info").textContent = `âœ… æ‰€æœ‰ ${loadedCount} ä¸ªåœ°å›¾åŠ è½½å®Œæˆã€‚`;
                        } else {
                             document.getElementById("info").textContent = `âŒ æœªèƒ½ä»åœ°å›¾åŒ…ä¸­åŠ è½½ä»»ä½•æœ‰æ•ˆåœ°å›¾ã€‚`;
                        }
                    });

                }).catch(function(error) {
                    console.error("è§£æ ZIP åŒ…é”™è¯¯:", error);
                    alert("è§£æåœ°å›¾åŒ…å¤±è´¥: " + error.message);
                    document.getElementById("info").textContent = "âŒ åœ°å›¾åŒ…è§£æå¤±è´¥";
                });
            };
            
            reader.onerror = function() {
                alert("åœ°å›¾åŒ…æ–‡ä»¶è¯»å–é”™è¯¯");
                document.getElementById("info").textContent = "âŒ æ–‡ä»¶è¯»å–é”™è¯¯";
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // åœ°å›¾åŒ…åŠ è½½æŒ‰é’®
        document.getElementById("fileInputBundle").addEventListener("change", function(e) {
            const file = e.target.files[0];
            if (file) {
                console.log("åŠ è½½åœ°å›¾åŒ…:", file.name);
                loadMapBundle(file);
            }
        });
        
        document.getElementById("fileInput110m").addEventListener("change", function(e) {
            const files = e.target.files;
            if (files.length === 0) return;
            
            const file = files[0];
            const fileName = file.name.toLowerCase();
            
            console.log("é€‰æ‹© 1:110m æ–‡ä»¶:", fileName);
            
            if (fileName.endsWith('.geojson') || fileName.endsWith('.json')) {
                loadGeoJSON(file, '110m');
            } else if (fileName.endsWith('.shp')) {
                loadShapefile(file, '110m');
            } else if (fileName.endsWith('.zip')) {
                loadZipFile(file, '110m');
            } else {
                alert("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼");
            }
        });
        
        document.getElementById("fileInput50m").addEventListener("change", function(e) {
            const files = e.target.files;
            if (files.length === 0) return;
            
            const file = files[0];
            const fileName = file.name.toLowerCase();
            
            console.log("é€‰æ‹© 1:50m æ–‡ä»¶:", fileName);
            
            if (fileName.endsWith('.geojson') || fileName.endsWith('.json')) {
                loadGeoJSON(file, '50m');
            } else if (fileName.endsWith('.shp')) {
                loadShapefile(file, '50m');
            } else if (fileName.endsWith('.zip')) {
                loadZipFile(file, '50m');
            } else {
                alert("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼");
            }
        });
        
        document.getElementById("fileInput10m").addEventListener("change", function(e) {
            const files = e.target.files;
            if (files.length === 0) return;
            
            const file = files[0];
            const fileName = file.name.toLowerCase();
            
            console.log("é€‰æ‹© 1:10m æ–‡ä»¶:", fileName);
            
            if (fileName.endsWith('.geojson') || fileName.endsWith('.json')) {
                loadGeoJSON(file, '10m');
            } else if (fileName.endsWith('.shp')) {
                loadShapefile(file, '10m');
            } else if (fileName.endsWith('.zip')) {
                loadZipFile(file, '10m');
            } else {
                alert("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼");
            }
        });
        
        document.getElementById("resetBtn").addEventListener("click", function() {
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity);
        });
        
        document.getElementById("toggleGraticule").addEventListener("click", function() {
            showGraticule = !showGraticule;
            graticulePath.style("display", showGraticule ? "block" : "none");
        });
        
        document.getElementById("toggleRotation").addEventListener("click", function() {
            isRotating = !isRotating;
            updateRotationStatus();
        });
        
        document.getElementById("clearConnections").addEventListener("click", function() {
            clearConnections();
            document.getElementById("info").textContent = "ğŸ—‘ï¸ å·²æ¸…é™¤æ‰€æœ‰è¿æ¥çº¿";
        });
        
        const lineWidthSlider = document.getElementById("lineWidthSlider");
        const lineWidthValue = document.getElementById("lineWidthValue");

        lineWidthSlider.addEventListener("input", function() {
            const newWidth = this.value;
            lineWidthValue.textContent = `${newWidth}px`;
            connectionsGroup.selectAll(".connection-arc").style("stroke-width", `${newWidth}px`);
        });
        
        function updateRotationStatus() {
            const btn = document.getElementById("toggleRotation");
            const status = document.getElementById("rotation-status");
            if (isRotating) {
                btn.textContent = "â¸ï¸ æš‚åœæ—‹è½¬";
                status.textContent = "è‡ªåŠ¨æ—‹è½¬ä¸­...";
            } else {
                btn.textContent = "â–¶ï¸ å¼€å§‹æ—‹è½¬";
                status.textContent = "æ—‹è½¬å·²æš‚åœ";
            }
        }
        
        function handleResize() {
            width = globeContainer.clientWidth;
            height = globeContainer.clientHeight;
            
            svg.attr('width', width).attr('height', height);
            
            initialScale = Math.min(width, height) / 2.2;
            
            const currentZoom = d3.zoomTransform(svg.node());
            
            projection
                .scale(initialScale * currentZoom.k)
                .translate([width / 2, height / 2]);

            svg.selectAll(".sphere, .country, .graticule").attr("d", path);
            updateConnections();
        }

        window.addEventListener('resize', handleResize);
        handleResize(); // Initial call
    </script>
</body>
</html>