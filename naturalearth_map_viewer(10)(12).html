<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ÁêÉÂΩ¢Âú∞ÁêÉËßÇÂØüÂô®</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/shapefile@0.6.6/dist/shapefile.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a14 100%);
            color: #eee;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(135deg, #16213e 0%, #0f1926 100%);
            padding: 15px 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 10;
            backdrop-filter: blur(10px);
            transform: translateY(-80%);
            transition: transform 0.3s ease-in-out;
        }

        #header.header-expanded,
        #header:hover {
            transform: translateY(0);
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
        
        #controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
            color: #0a0a14;
            padding: 10px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }
        
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
        }
        
        button {
            background: rgba(15, 52, 96, 0.8);
            color: #00d4ff;
            border: 2px solid #00d4ff;
            padding: 8px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        button:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }
        
        #info {
            color: #88ddff;
            font-size: 13px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        #map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #globe-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        svg {
            width: 100%;
            height: 100%;
        }
        
        .sphere {
            fill: url(#ocean-gradient);
        }
        
        .country {
            fill: #1e3a5f;
            stroke: #00d4ff;
            stroke-width: 0.5;
            transition: all 0.3s;
        }
        
        .country:hover {
            fill: #2d5a8f;
            stroke: #00ffff;
            stroke-width: 1.5;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.8));
            cursor: pointer;
        }
        
        .country.selected {
            fill: #ff6b35;
            stroke: #ffaa00;
            stroke-width: 2;
        }
        
        .connection-arc {
            fill: none;
            stroke: #00ffff;
            opacity: 0.6;
            filter: drop-shadow(0 0 8px rgba(0, 255, 255, 0.8));
            pointer-events: none;
        }
        
        .connection-point {
            fill: #ff6b35;
            stroke: #ffaa00;
            stroke-width: 2;
            filter: drop-shadow(0 0 10px rgba(255, 107, 53, 0.8));
        }
        
        .graticule {
            fill: none;
            stroke: rgba(0, 212, 255, 0.2);
            stroke-width: 0.5;
        }
        
        #tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.95) 0%, rgba(0, 150, 255, 0.95) 100%);
            color: #0a0a14;
            padding: 10px 16px;
            border-radius: 8px;
            pointer-events: none;
            display: none;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        #legend {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(22, 33, 62, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #00d4ff;
            font-size: 13px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .legend-title {
            font-weight: bold;
            margin-bottom: 12px;
            color: #00d4ff;
            font-size: 15px;
            text-shadow: 0 2px 4px rgba(0, 212, 255, 0.5);
        }
        
        .legend-item {
            margin: 8px 0;
            color: #88ddff;
        }
        
        #rotation-info {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(22, 33, 62, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid #00d4ff;
            font-size: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            color: #88ddff;
            font-family: 'Courier New', monospace;
        }
        
        #debug-info {
            position: absolute;
            top: 120px;
            right: 30px;
            background: rgba(22, 33, 62, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid #ff8800;
            font-size: 11px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            color: #ffaa44;
            font-family: 'Courier New', monospace;
            max-width: 300px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff88;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>üåç 3D ÁêÉÂΩ¢Âú∞ÁêÉËßÇÂØüÂô®</h1>
            <div id="controls">
                <div class="file-input-wrapper">
                    <label for="fileInputBundle" class="file-input-label">üì¶ Âä†ËΩΩÂú∞ÂõæÂåÖÔºàZIPÔºâ</label>
                    <input type="file" id="fileInputBundle" accept=".zip" />
                </div>
                <div style="margin-left: 10px; color: #88ddff; font-size: 12px;">
                    ÊàñÂçïÁã¨Âä†ËΩΩÔºö
                </div>
                <div class="file-input-wrapper">
                    <label for="fileInput110m" class="file-input-label" style="font-size: 12px; padding: 6px 12px;">1:110m</label>
                    <input type="file" id="fileInput110m" accept=".geojson,.json,.shp,.zip" multiple />
                </div>
                <div class="file-input-wrapper">
                    <label for="fileInput50m" class="file-input-label" style="font-size: 12px; padding: 6px 12px;">1:50m</label>
                    <input type="file" id="fileInput50m" accept=".geojson,.json,.shp,.zip" multiple />
                </div>
                <div class="file-input-wrapper">
                    <label for="fileInput10m" class="file-input-label" style="font-size: 12px; padding: 6px 12px;">1:10m</label>
                    <input type="file" id="fileInput10m" accept=".geojson,.json,.shp,.zip" multiple />
                </div>
                <button id="resetBtn">üîÑ ÈáçÁΩÆËßÜÂõæ</button>
                <button id="toggleGraticule">üåê ÂàáÊç¢ÁªèÁ∫¨ÁΩë</button>
                <button id="toggleRotation">‚ñ∂Ô∏è ÂºÄÂßãÊóãËΩ¨</button>
                <button id="clearConnections">üóëÔ∏è Ê∏ÖÈô§ËøûÊé•Á∫ø</button>
                <div style="display: flex; align-items: center; gap: 10px; color: #88ddff;">
                    <label for="lineWidthSlider">Á∫øÂÆΩ:</label>
                    <input type="range" id="lineWidthSlider" min="1" max="20" value="2.5" step="0.5" style="cursor: pointer;">
                    <span id="lineWidthValue">2.5px</span>
                </div>
                <span id="info">ËØ∑Âä†ËΩΩÂú∞ÂõæÂåÖÊàñÂçïÁã¨Âä†ËΩΩÂêÑÁ∫ßÂà´Âú∞Âõæ</span>
            </div>
        </div>
        
        <div id="map-container">
            <div id="globe-container">
                <svg id="globe"></svg>
            </div>
            <div id="tooltip"></div>
            <div id="legend">
                <div class="legend-title">üéÆ Êìç‰ΩúËØ¥Êòé</div>
                <div class="legend-item">üñ±Ô∏è ÊãñÊãΩ: ÊóãËΩ¨Âú∞ÁêÉÔºà‰ªªÊÑèÊñπÂêëÔºâ</div>
                <div class="legend-item">üñ±Ô∏è ÊªöËΩÆ: Áº©ÊîæËßÜÂõæ</div>
                <div class="legend-item">üñ±Ô∏è ÊÇ¨ÂÅú: Êü•ÁúãÂõΩÂÆ∂</div>
                <div class="legend-item">üëÜ ÁÇπÂáª: ÈÄâÊã©‰∏§‰∏™Âú∞ÁÇπËøûÁ∫ø</div>
                <div class="legend-item">‚è∏Ô∏è ÊåâÈíÆ: ÊéßÂà∂Ëá™Âä®ÊóãËΩ¨</div>
            </div>
            <div id="rotation-info">
                <span class="status-indicator"></span>
                <span id="rotation-status">ÊóãËΩ¨Â∑≤ÊöÇÂÅú</span>
            </div>
            <div id="debug-info">
                <div><strong>üîç Ë∞ÉËØï‰ø°ÊÅØ</strong></div>
                <div>ÁªèÂ∫¶: <span id="debug-lon">0¬∞</span></div>
                <div>Á∫¨Â∫¶: <span id="debug-lat">0¬∞</span></div>
                <div>Áº©Êîæ: <span id="debug-zoom">1.0x</span></div>
                <div>ÂΩìÂâçÂú∞Âõæ: <span id="debug-lod">Êú™Âä†ËΩΩ</span></div>
                <div>ÂèØËßÅÂõΩÂÆ∂: <span id="debug-visible">0</span></div>
                <div>ÊÄªÂõΩÂÆ∂Êï∞: <span id="debug-total">0</span></div>
                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ffaa44;">
                    <strong>üìç ËøûÊé•Á∫øÊ®°Âºè</strong><br>
                    <span id="connection-mode">ÂæÖÈÄâÊã©Ëµ∑ÁÇπ</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const svg = d3.select("#globe");
        const globeContainer = document.getElementById('globe-container');
        let width, height, initialScale;

        // ÂàõÂª∫Ê∏êÂèò
        const defs = svg.append("defs");
        const oceanGradient = defs.append("radialGradient")
            .attr("id", "ocean-gradient");
        oceanGradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", "#1a3d5c");
        oceanGradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", "#0a1929");
        
        const projection = d3.geoOrthographic()
            .rotate([0, 0, 0])
            .clipAngle(90);
        
        const path = d3.geoPath().projection(projection);
        const graticule = d3.geoGraticule();
        
        // ÁªòÂà∂ÁêÉ‰Ωì
        svg.append("path")
            .datum({type: "Sphere"})
            .attr("class", "sphere")
            .attr("d", path);
        
        const g = svg.append("g");
        const connectionsGroup = svg.append("g").attr("class", "connections");
        
        // ÁªòÂà∂ÁªèÁ∫¨ÁΩë
        let graticulePath = g.append("path")
            .datum(graticule)
            .attr("class", "graticule")
            .attr("d", path);
        
        let showGraticule = true;
        let isRotating = false;
        let rotation = [0, 0];
        
        let currentGeoJSON = null;
        let selectedPoints = [];
        let connections = [];
        
        // LOD Á≥ªÁªüÔºöÂ≠òÂÇ®‰∏çÂêåÁ≤æÂ∫¶ÁöÑÂú∞Âõæ
        let mapLOD = {
            '110m': null,  // ÊúÄÁ≤óÁ≥ôÔºåÁº©Êîæ 0.5 - 1.5
            '50m': null,   // ‰∏≠Á≠âÔºåÁº©Êîæ 1.5 - 3.0
            '10m': null    // ÊúÄÁ≤æÁªÜÔºåÁº©Êîæ 3.0+
        };
        let currentLOD = null;
        
        // Ê†πÊçÆÁº©ÊîæÁ∫ßÂà´ÂàáÊç¢Âú∞Âõæ
        function switchLOD(zoomLevel) {
            let targetLOD = null;
            
            if (zoomLevel < 1.5) {
                targetLOD = '110m';
            } else if (zoomLevel < 3.0) {
                targetLOD = '50m';
            } else {
                targetLOD = '10m';
            }
            
            // Â¶ÇÊûúÁõÆÊ†á LOD Ê≤°ÊúâÂä†ËΩΩÔºå‰ΩøÁî®Â∑≤Âä†ËΩΩÁöÑÊúÄÊé•ËøëÁöÑ
            if (!mapLOD[targetLOD]) {
                if (targetLOD === '110m') {
                    targetLOD = mapLOD['50m'] ? '50m' : (mapLOD['10m'] ? '10m' : null);
                } else if (targetLOD === '50m') {
                    targetLOD = mapLOD['110m'] ? '110m' : (mapLOD['10m'] ? '10m' : null);
                } else if (targetLOD === '10m') {
                    targetLOD = mapLOD['50m'] ? '50m' : (mapLOD['110m'] ? '110m' : null);
                }
            }
            
            // Â¶ÇÊûúÈúÄË¶ÅÂàáÊç¢
            if (targetLOD && targetLOD !== currentLOD && mapLOD[targetLOD]) {
                console.log(`ÂàáÊç¢Âà∞ ${targetLOD} Âú∞Âõæ (Áº©Êîæ: ${zoomLevel.toFixed(2)})`);
                currentLOD = targetLOD;
                currentGeoJSON = mapLOD[targetLOD];
                renderCurrentMap();
                document.getElementById('debug-lod').textContent = targetLOD;
            }
        }
        
        // Ê∏≤ÊüìÂΩìÂâçÂú∞Âõæ
        function renderCurrentMap() {
            if (!currentGeoJSON) return;
            
            g.selectAll(".country").remove();
            
            g.selectAll(".country")
                .data(currentGeoJSON.features)
                .enter()
                .append("path")
                .attr("class", "country")
                .attr("d", path)
                .on("click", function(event, d) {
                    event.stopPropagation();
                    
                    const centroid = d3.geoCentroid(d);
                    
                    if (selectedPoints.length === 0) {
                        selectedPoints.push(centroid);
                        d3.select(this).classed("selected", true);
                        updateConnectionMode();
                        
                        const name = d.properties.NAME || d.properties.name || 
                                   d.properties.ADMIN || d.properties.admin || "Êú™Áü•";
                        document.getElementById("info").textContent = `‚úÖ Â∑≤ÈÄâÊã©Ëµ∑ÁÇπ: ${name}`;
                    } else if (selectedPoints.length === 1) {
                        selectedPoints.push(centroid);
                        
                        const name = d.properties.NAME || d.properties.name || 
                                   d.properties.ADMIN || d.properties.admin || "Êú™Áü•";
                        document.getElementById("info").textContent = `‚úÖ Â∑≤ÂàõÂª∫ËøûÊé•Á∫øÂà∞: ${name}`;
                        
                        drawConnection(selectedPoints[0], selectedPoints[1]);
                        
                        selectedPoints = [];
                        g.selectAll(".country").classed("selected", false);
                        updateConnectionMode();
                    }
                })
                .on("mouseover", function(event, d) {
                    const name = d.properties.NAME || d.properties.name || 
                               d.properties.ADMIN || d.properties.admin || 
                               d.properties.NAME_LONG || d.properties.NAME_EN || 
                               d.properties.COUNTRY || "Êú™Áü•";
                    tooltip
                        .style("display", "block")
                        .html(name);
                })
                .on("mousemove", function(event) {
                    tooltip
                        .style("left", (event.pageX + 15) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("display", "none");
                });
        }
        
        // Êõ¥Êñ∞ËøûÊé•Á∫øÁä∂ÊÄÅÊòæÁ§∫
        function updateConnectionMode() {
            const modeText = document.getElementById('connection-mode');
            if (selectedPoints.length === 0) {
                modeText.textContent = 'ÂæÖÈÄâÊã©Ëµ∑ÁÇπ';
                modeText.style.color = '#ffaa44';
            } else if (selectedPoints.length === 1) {
                modeText.textContent = 'Â∑≤ÈÄâËµ∑ÁÇπÔºåÈÄâÊã©ÁªàÁÇπ';
                modeText.style.color = '#00ff88';
            }
        }
        
        // ÁªòÂà∂ËøûÊé•Á∫ø
        function drawConnection(point1, point2) {
            // ‰ΩøÁî® D3 ÁöÑÁêÉÈù¢ÊèíÂÄºÂàõÂª∫Â§ßÂúÜÂºß
            const interpolate = d3.geoInterpolate(point1, point2);
            
            // ÁîüÊàêÂºßÁ∫ø‰∏äÁöÑÁÇπ
            const points = [];
            for (let i = 0; i <= 100; i++) {
                points.push(interpolate(i / 100));
            }
            
            // ÂàõÂª∫ LineString
            const arcLine = {
                type: "LineString",
                coordinates: points
            };
            
            const currentLineWidth = document.getElementById("lineWidthSlider").value;

            // ÁªòÂà∂ÂºßÁ∫ø
            connectionsGroup.append("path")
                .datum(arcLine)
                .attr("class", "connection-arc")
                .attr("d", path)
                .style("stroke-width", `${currentLineWidth}px`);
            
            // ÁªòÂà∂Ëµ∑ÁÇπÂíåÁªàÁÇπÊ†áËÆ∞
            const center = [-projection.rotate()[0], -projection.rotate()[1]];

            const isVisible1 = d3.geoDistance(point1, center) < Math.PI / 2;
            const p1 = projection(point1);
            connectionsGroup.append("circle")
                .datum({type: "Point", coordinates: point1})
                .attr("class", "connection-point")
                .attr("cx", p1 ? p1[0] : -999)
                .attr("cy", p1 ? p1[1] : -999)
                .attr("r", 5)
                .style("display", isVisible1 ? "block" : "none");

            const isVisible2 = d3.geoDistance(point2, center) < Math.PI / 2;
            const p2 = projection(point2);
            connectionsGroup.append("circle")
                .datum({type: "Point", coordinates: point2})
                .attr("class", "connection-point")
                .attr("cx", p2 ? p2[0] : -999)
                .attr("cy", p2 ? p2[1] : -999)
                .attr("r", 5)
                .style("display", isVisible2 ? "block" : "none");
            
            // ‰øùÂ≠òËøûÊé•
            connections.push({point1, point2, arcLine});
        }
        
        // Êõ¥Êñ∞ÊâÄÊúâËøûÊé•Á∫øÁöÑ‰ΩçÁΩÆ
        function updateConnections() {
            connectionsGroup.selectAll("path").attr("d", path);
            
            const center = [-projection.rotate()[0], -projection.rotate()[1]];
            
            connectionsGroup.selectAll("circle")
                .each(function(d) {
                    const circle = d3.select(this);
                    const isVisible = d3.geoDistance(d.coordinates, center) < Math.PI / 2;
                    
                    if (isVisible) {
                        const p = projection(d.coordinates);
                        circle.attr("cx", p[0])
                              .attr("cy", p[1])
                              .style("display", "block");
                    } else {
                        circle.style("display", "none");
                    }
                });
        }
        
        // Ê∏ÖÈô§ÊâÄÊúâËøûÊé•Á∫ø
        function clearConnections() {
            connectionsGroup.selectAll("*").remove();
            connections = [];
            selectedPoints = [];
            g.selectAll(".country").classed("selected", false);
            updateConnectionMode();
        }
        
        // Êõ¥Êñ∞Ë∞ÉËØï‰ø°ÊÅØ
        function updateDebugInfo() {
            const rotate = projection.rotate();
            document.getElementById('debug-lon').textContent = rotate[0].toFixed(1) + '¬∞';
            document.getElementById('debug-lat').textContent = rotate[1].toFixed(1) + '¬∞';
            
            if (initialScale) {
                const scale = projection.scale() / initialScale;
                document.getElementById('debug-zoom').textContent = scale.toFixed(2) + 'x';
            }
            
            if (currentGeoJSON) {
                const visible = g.selectAll('.country').nodes().filter(node => {
                    const display = d3.select(node).style('display');
                    const visibility = d3.select(node).style('visibility');
                    return display !== 'none' && visibility !== 'hidden';
                }).length;
                
                document.getElementById('debug-visible').textContent = visible;
                document.getElementById('debug-total').textContent = currentGeoJSON.features.length;
            }
            
            // Êõ¥Êñ∞ËøûÊé•Á∫ø‰ΩçÁΩÆ
            updateConnections();
        }
        
        // Ëá™Âä®ÊóãËΩ¨
        const rotationSpeed = 0.3;
        let rotationTimer = d3.timer(function(elapsed) {
            if (isRotating) {
                rotation[0] = (rotation[0] + rotationSpeed) % 360;
                projection.rotate(rotation);
                svg.selectAll(".sphere, .country, .graticule").attr("d", path);
                updateDebugInfo();
            }
        });
        
        // ÊãñÊãΩÊóãËΩ¨ - ÊÅ¢Â§ç‰∏ä‰∏ãÂ∑¶Âè≥ÊóãËΩ¨
        const drag = d3.drag()
            .on("start", function(event) {
                isRotating = false;
                updateRotationStatus();
            })
            .on("drag", function(event) {
                const rotate = projection.rotate();
                const k = 75 / projection.scale();
                // ÊÅ¢Â§çÂÆåÊï¥ÁöÑÊóãËΩ¨ÔºöÂ∑¶Âè≥Âíå‰∏ä‰∏ã
                projection.rotate([
                    rotate[0] + event.dx * k,
                    rotate[1] - event.dy * k  // ÊÅ¢Â§çÁ∫¨Â∫¶ÊóãËΩ¨
                ]);
                rotation = projection.rotate();
                svg.selectAll(".sphere, .country, .graticule").attr("d", path);
                updateDebugInfo();
            });
        
        svg.call(drag);
        
        // Áº©Êîæ
        const zoom = d3.zoom()
            .scaleExtent([0.5, 100])
            .on("zoom", function(event) {
                if (!initialScale) return;
                projection.scale(initialScale * event.transform.k);
                
                // Ê†πÊçÆÁº©ÊîæÁ∫ßÂà´ÂàáÊç¢Âú∞Âõæ
                switchLOD(event.transform.k);
                
                svg.selectAll(".sphere, .country, .graticule").attr("d", path);
                updateDebugInfo();
            });
        
        svg.call(zoom);
        
        const tooltip = d3.select("#tooltip");
        
        function renderGeoJSON(geojson) {
            console.log("Ê∏≤ÊüìÂú∞ÂõæÊï∞ÊçÆ:", geojson);
            
            if (!geojson || !geojson.features || geojson.features.length === 0) {
                alert("Âú∞ÂõæÊï∞ÊçÆ‰∏∫Á©∫ÊàñÊ†ºÂºè‰∏çÊ≠£Á°Æ");
                document.getElementById("info").textContent = "‚ùå Âú∞ÂõæÊï∞ÊçÆÊó†Êïà";
                return;
            }
            
            currentGeoJSON = geojson;
            renderCurrentMap();
            
            console.log("Â∑≤Ê∏≤Êüì", geojson.features.length, "‰∏™Ë¶ÅÁ¥†");
            document.getElementById("info").textContent = 
                `‚úÖ Â∑≤Âä†ËΩΩÂú∞Âõæ (${geojson.features.length} ‰∏™Âú∞ÁêÜË¶ÅÁ¥†)`;
            
            // ÂàùÂßãÂåñË∞ÉËØï‰ø°ÊÅØ
            updateDebugInfo();
        }
        
        function renderGeoJSONToLOD(geojson, lodLevel) {
            console.log(`Âä†ËΩΩ ${lodLevel} Âú∞Âõæ:`, geojson);
            
            if (!geojson || !geojson.features || geojson.features.length === 0) {
                alert("Âú∞ÂõæÊï∞ÊçÆ‰∏∫Á©∫ÊàñÊ†ºÂºè‰∏çÊ≠£Á°Æ");
                return;
            }
            
            mapLOD[lodLevel] = geojson;
            
            // Â¶ÇÊûúÊòØÁ¨¨‰∏ÄÊ¨°Âä†ËΩΩÔºåÊàñËÄÖÂΩìÂâçÊ≤°ÊúâÂú∞ÂõæÔºå‰ΩøÁî®Ëøô‰∏™
            if (!currentGeoJSON) {
                currentLOD = lodLevel;
                currentGeoJSON = geojson;
                renderCurrentMap();
                document.getElementById('debug-lod').textContent = lodLevel;
            }
            
            console.log(`${lodLevel} Âú∞ÂõæÂ∑≤Âä†ËΩΩ (${geojson.features.length} ‰∏™Ë¶ÅÁ¥†)`);
            document.getElementById("info").textContent = 
                `‚úÖ ${lodLevel} Âú∞ÂõæÂ∑≤Âä†ËΩΩ (${geojson.features.length} ‰∏™Ë¶ÅÁ¥†)`;
            
            updateDebugInfo();
        }
        
        function loadGeoJSON(file, lodLevel) {
            document.getElementById("info").textContent = `‚è≥ Ê≠£Âú®Âä†ËΩΩ ${lodLevel} GeoJSON...`;
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const geojson = JSON.parse(e.target.result);
                    console.log(`${lodLevel} GeoJSON Ëß£ÊûêÊàêÂäü:`, geojson);
                    renderGeoJSONToLOD(geojson, lodLevel);
                } catch (error) {
                    console.error("GeoJSON Ëß£ÊûêÈîôËØØ:", error);
                    alert("GeoJSON Êñá‰ª∂Ëß£ÊûêÂ§±Ë¥•: " + error.message);
                    document.getElementById("info").textContent = "‚ùå Âä†ËΩΩÂ§±Ë¥•";
                }
            };
            
            reader.onerror = function() {
                alert("GeoJSON Êñá‰ª∂ËØªÂèñÈîôËØØ");
                document.getElementById("info").textContent = "‚ùå Êñá‰ª∂ËØªÂèñÈîôËØØ";
            };
            
            reader.readAsText(file);
        }
        
        function loadShapefile(file, lodLevel) {
            document.getElementById("info").textContent = `‚è≥ Ê≠£Âú®Âä†ËΩΩ ${lodLevel} Shapefile...`;
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    console.log(`ÂºÄÂßãËß£Êûê ${lodLevel} Shapefile, Â§ßÂ∞è:`, arrayBuffer.byteLength);
                    
                    if (typeof shapefile === 'undefined') {
                        alert("Shapefile Â∫ìÊú™Âä†ËΩΩÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØïÊàñ‰ΩøÁî® GeoJSON Ê†ºÂºè");
                        document.getElementById("info").textContent = "‚ùå Shapefile Â∫ìÊú™Âä†ËΩΩ";
                        return;
                    }
                    
                    shapefile.open(arrayBuffer)
                        .then(source => {
                            const features = [];
                            
                            function readNext() {
                                return source.read().then(result => {
                                    if (result.done) {
                                        return features;
                                    }
                                    features.push(result.value);
                                    return readNext();
                                });
                            }
                            
                            return readNext();
                        })
                        .then(function(features) {
                            console.log(`ËØªÂèñÂà∞ ${lodLevel}`, features.length, "‰∏™Ë¶ÅÁ¥†");
                            const geojson = {
                                type: "FeatureCollection",
                                features: features
                            };
                            renderGeoJSONToLOD(geojson, lodLevel);
                        })
                        .catch(function(error) {
                            console.error("Shapefile Ëß£ÊûêÈîôËØØ:", error);
                            alert("Shapefile Ëß£ÊûêÂ§±Ë¥•: " + error.message);
                            document.getElementById("info").textContent = "‚ùå Shapefile Âä†ËΩΩÂ§±Ë¥•";
                        });
                } catch (error) {
                    console.error("ËØªÂèñÊñá‰ª∂ÈîôËØØ:", error);
                    alert("ËØªÂèñÊñá‰ª∂Â§±Ë¥•: " + error.message);
                    document.getElementById("info").textContent = "‚ùå Êñá‰ª∂ËØªÂèñÂ§±Ë¥•";
                }
            };
            
            reader.onerror = function() {
                alert("Êñá‰ª∂ËØªÂèñÈîôËØØ");
                document.getElementById("info").textContent = "‚ùå Êñá‰ª∂ËØªÂèñÈîôËØØ";
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        function parseAndLoadShapefile(zipBuffer, lodLevel, filenameHint) {
            return shapefile.open(zipBuffer)
                .then(source => {
                    const features = [];
                    function readNext() {
                        return source.read().then(result => {
                            if (result.done) return features;
                            features.push(result.value);
                            return readNext();
                        });
                    }
                    return readNext();
                })
                .then(features => {
                    const geojson = { type: "FeatureCollection", features: features };
                    renderGeoJSONToLOD(geojson, lodLevel);
                    return { lodLevel, features };
                })
                .catch(error => {
                    console.error(`Âä†ËΩΩ ${lodLevel} Âú∞Âõæ (${filenameHint}) Â§±Ë¥•:`, error);
                    alert(`Âä†ËΩΩ ${lodLevel} Âú∞Âõæ (${filenameHint}) Â§±Ë¥•: ${error.message}`);
                });
        }

        function loadZipFile(file, lodLevel) {
            document.getElementById("info").textContent = `‚è≥ Ê≠£Âú®Âä†ËΩΩ ${lodLevel} ZIP Êñá‰ª∂...`;
            const reader = new FileReader();
            reader.onload = (e) => parseAndLoadShapefile(e.target.result, lodLevel, file.name);
            reader.onerror = () => {
                alert("Êñá‰ª∂ËØªÂèñÈîôËØØ");
                document.getElementById("info").textContent = "‚ùå Êñá‰ª∂ËØªÂèñÈîôËØØ";
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Âä†ËΩΩÂåÖÂê´Â§ö‰∏™Á≤æÂ∫¶Âú∞ÂõæÁöÑZIPÂåÖ
        function loadMapBundle(file) {
            document.getElementById("info").textContent = "‚è≥ Ê≠£Âú®Ëß£ÊûêÂú∞ÂõæÂåÖ...";
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                
                if (typeof JSZip === 'undefined' || typeof shapefile === 'undefined') {
                    alert("ÊâÄÈúÄÂ∫ìÔºàJSZip, ShapefileÔºâÊú™Âä†ËΩΩÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï„ÄÇ");
                    return;
                }
                
                JSZip.loadAsync(arrayBuffer).then(function(zip) {
                    const shpFiles = Object.keys(zip.files).filter(name => name.endsWith('.shp') && !zip.files[name].dir);
                    
                    if (shpFiles.length === 0) {
                        alert("Âú∞ÂõæÂåÖ‰∏≠Êú™ÊâæÂà∞ .shp Êñá‰ª∂„ÄÇ");
                        document.getElementById("info").textContent = "‚ùå Êú™ÊâæÂà∞ Shapefile";
                        return;
                    }

                    document.getElementById("info").textContent = `‚è≥ ÊâæÂà∞ ${shpFiles.length} ‰∏™ ShapefileÔºåÂºÄÂßãÂä†ËΩΩ...`;
                    let loadedCount = 0;
                    
                    const loadPromises = shpFiles.map(shpFilename => {
                        const basename = shpFilename.replace(/\.shp$/, '');
                        const lodMatch = basename.match(/(\d+m)/);
                        
                        if (!lodMatch) {
                            console.warn(`Êó†Ê≥ï‰ªéÊñá‰ª∂Âêç ${shpFilename} ‰∏≠ËØÜÂà´ÂàÜËæ®ÁéáÔºåÂ∑≤Ë∑≥Ëøá„ÄÇ`);
                            return Promise.resolve(); // Skip this file
                        }
                        const lodLevel = lodMatch[1];
                        
                        const relatedFiles = Object.keys(zip.files).filter(name => name.startsWith(basename) && !zip.files[name].dir);
                        const subZip = new JSZip();
                        const filePromises = relatedFiles.map(filename => {
                            return zip.files[filename].async("arraybuffer").then(content => {
                                subZip.file(filename.split('/').pop(), content);
                            });
                        });
                        
                        return Promise.all(filePromises)
                            .then(() => subZip.generateAsync({type: "arraybuffer"}))
                            .then(subZipBuffer => parseAndLoadShapefile(subZipBuffer, lodLevel, shpFilename))
                            .then(result => {
                                if (result) {
                                    loadedCount++;
                                    document.getElementById("info").textContent = 
                                        `‚úÖ Â∑≤Âä†ËΩΩ ${loadedCount}/${shpFiles.length} ‰∏™Âú∞Âõæ (${result.lodLevel}: ${result.features.length} Ë¶ÅÁ¥†)`;
                                }
                            });
                    });

                    Promise.all(loadPromises).then(() => {
                        if (loadedCount > 0) {
                             document.getElementById("info").textContent = `‚úÖ ÊâÄÊúâ ${loadedCount} ‰∏™Âú∞ÂõæÂä†ËΩΩÂÆåÊàê„ÄÇ`;
                        } else {
                             document.getElementById("info").textContent = `‚ùå Êú™ËÉΩ‰ªéÂú∞ÂõæÂåÖ‰∏≠Âä†ËΩΩ‰ªª‰ΩïÊúâÊïàÂú∞Âõæ„ÄÇ`;
                        }
                    });

                }).catch(function(error) {
                    console.error("Ëß£Êûê ZIP ÂåÖÈîôËØØ:", error);
                    alert("Ëß£ÊûêÂú∞ÂõæÂåÖÂ§±Ë¥•: " + error.message);
                    document.getElementById("info").textContent = "‚ùå Âú∞ÂõæÂåÖËß£ÊûêÂ§±Ë¥•";
                });
            };
            
            reader.onerror = function() {
                alert("Âú∞ÂõæÂåÖÊñá‰ª∂ËØªÂèñÈîôËØØ");
                document.getElementById("info").textContent = "‚ùå Êñá‰ª∂ËØªÂèñÈîôËØØ";
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // Âú∞ÂõæÂåÖÂä†ËΩΩÊåâÈíÆ
        document.getElementById("fileInputBundle").addEventListener("change", function(e) {
            const file = e.target.files[0];
            if (file) {
                console.log("Âä†ËΩΩÂú∞ÂõæÂåÖ:", file.name);
                loadMapBundle(file);
            }
        });
        
        document.getElementById("fileInput110m").addEventListener("change", function(e) {
            const files = e.target.files;
            if (files.length === 0) return;
            
            const file = files[0];
            const fileName = file.name.toLowerCase();
            
            console.log("ÈÄâÊã© 1:110m Êñá‰ª∂:", fileName);
            
            if (fileName.endsWith('.geojson') || fileName.endsWith('.json')) {
                loadGeoJSON(file, '110m');
            } else if (fileName.endsWith('.shp')) {
                loadShapefile(file, '110m');
            } else if (fileName.endsWith('.zip')) {
                loadZipFile(file, '110m');
            } else {
                alert("‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Ê†ºÂºè");
            }
        });
        
        document.getElementById("fileInput50m").addEventListener("change", function(e) {
            const files = e.target.files;
            if (files.length === 0) return;
            
            const file = files[0];
            const fileName = file.name.toLowerCase();
            
            console.log("ÈÄâÊã© 1:50m Êñá‰ª∂:", fileName);
            
            if (fileName.endsWith('.geojson') || fileName.endsWith('.json')) {
                loadGeoJSON(file, '50m');
            } else if (fileName.endsWith('.shp')) {
                loadShapefile(file, '50m');
            } else if (fileName.endsWith('.zip')) {
                loadZipFile(file, '50m');
            } else {
                alert("‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Ê†ºÂºè");
            }
        });
        
        document.getElementById("fileInput10m").addEventListener("change", function(e) {
            const files = e.target.files;
            if (files.length === 0) return;
            
            const file = files[0];
            const fileName = file.name.toLowerCase();
            
            console.log("ÈÄâÊã© 1:10m Êñá‰ª∂:", fileName);
            
            if (fileName.endsWith('.geojson') || fileName.endsWith('.json')) {
                loadGeoJSON(file, '10m');
            } else if (fileName.endsWith('.shp')) {
                loadShapefile(file, '10m');
            } else if (fileName.endsWith('.zip')) {
                loadZipFile(file, '10m');
            } else {
                alert("‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Ê†ºÂºè");
            }
        });
        
        document.getElementById("resetBtn").addEventListener("click", function() {
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity);
        });
        
        document.getElementById("toggleGraticule").addEventListener("click", function() {
            showGraticule = !showGraticule;
            graticulePath.style("display", showGraticule ? "block" : "none");
        });
        
        document.getElementById("toggleRotation").addEventListener("click", function() {
            isRotating = !isRotating;
            updateRotationStatus();
        });
        
        document.getElementById("clearConnections").addEventListener("click", function() {
            clearConnections();
            document.getElementById("info").textContent = "üóëÔ∏è Â∑≤Ê∏ÖÈô§ÊâÄÊúâËøûÊé•Á∫ø";
        });
        
        const lineWidthSlider = document.getElementById("lineWidthSlider");
        const lineWidthValue = document.getElementById("lineWidthValue");

        lineWidthSlider.addEventListener("input", function() {
            const newWidth = this.value;
            lineWidthValue.textContent = `${newWidth}px`;
            connectionsGroup.selectAll(".connection-arc").style("stroke-width", `${newWidth}px`);
        });
        
        function updateRotationStatus() {
            const btn = document.getElementById("toggleRotation");
            const status = document.getElementById("rotation-status");
            if (isRotating) {
                btn.textContent = "‚è∏Ô∏è ÊöÇÂÅúÊóãËΩ¨";
                status.textContent = "Ëá™Âä®ÊóãËΩ¨‰∏≠...";
            } else {
                btn.textContent = "‚ñ∂Ô∏è ÂºÄÂßãÊóãËΩ¨";
                status.textContent = "ÊóãËΩ¨Â∑≤ÊöÇÂÅú";
            }
        }
        
        function handleResize() {
            width = globeContainer.clientWidth;
            height = globeContainer.clientHeight;
            
            svg.attr('width', width).attr('height', height);
            
            initialScale = Math.min(width, height) / 2.2;
            
            const currentZoom = d3.zoomTransform(svg.node());
            
            projection
                .scale(initialScale * currentZoom.k)
                .translate([width / 2, height / 2]);

            svg.selectAll(".sphere, .country, .graticule").attr("d", path);
            updateConnections();
        }

        window.addEventListener('resize', handleResize);
        handleResize(); // Initial call
    </script>
</body>
</html>