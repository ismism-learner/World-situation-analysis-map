<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>世界情势标注系统</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            overflow: hidden;
        }

        #map {
            width: 100vw;
            height: 100vh;
            cursor: default;
        }

        #map.pan-mode { cursor: grab; }
        #map.pan-mode:active { cursor: grabbing; }
        #map.eraser-mode { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><text y="20" font-size="20">🧹</text></svg>') 12 12, auto; }

        #zoom-control {
            position: fixed;
            left: 16.08px;
            top: 50%;
            transform: translateY(-50%) scale(0.804);
            transform-origin: left center;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            padding: 20px 15px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        #zoom-slider-container {
            position: relative;
            height: 300px;
            width: 6px;
            background: rgba(200, 200, 200, 0.5);
            border-radius: 3px;
        }

        #zoom-slider-track {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #666666;
            border-radius: 3px;
            transition: height 0.2s;
        }

        #zoom-slider-thumb {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 18px;
            height: 18px;
            background: white;
            border: 2px solid #666666;
            border-radius: 50%;
            cursor: grab;
            transition: bottom 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        #zoom-slider-thumb:active {
            cursor: grabbing;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        #zoom-levels {
            display: flex;
            flex-direction: column-reverse;
            justify-content: space-between;
            height: 300px;
            user-select: none;
            position: relative;
        }

        .zoom-level-mark {
            height: 2px;
            display: flex;
            align-items: center;
            position: relative;
        }

        .zoom-level-mark::before {
            content: '';
            position: absolute;
            left: 0;
            width: 8px;
            height: 2px;
            background: #999;
            border-radius: 1px;
        }

        .zoom-level-mark.current::before {
            background: #666666;
            width: 12px;
            height: 3px;
        }

        #date-selector {
            position: fixed;
            top: 16.08px;
            left: 50%;
            transform: translateX(-50%) scale(0.804);
            transform-origin: top center;
            background: rgba(255, 255, 255, 0.5); 
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 320px;
        }

        #date-display {
            font-size: 18px;
            font-weight: bold;
            color: #666; 
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background 0.2s;
        }

        #date-display:hover {
            background: rgba(102, 102, 102, 0.1); 
        }

        #calendar-container {
            display: none;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            width: 280px;
        }

        #calendar-container.show {
            display: block;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .calendar-header button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .calendar-header button:hover {
            opacity: 0.9;
        }

        .calendar-header select {
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }

        .calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin-bottom: 5px;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
        }

        .calendar-day-header {
            text-align: center;
            font-weight: bold;
            font-size: 12px;
            padding: 5px;
            color: #666;
        }

        .calendar-day {
            text-align: center;
            padding: 8px 5px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s;
        }

        .calendar-day:hover {
            background: #e3f2fd;
        }

        .calendar-day.other-month {
            color: #ccc;
        }

        .calendar-day.selected {
            background: #4CAF50;
            color: white;
        }

        .calendar-day.today {
            border: 2px solid #2196F3;
        }

        .btn {
            padding: 8px 15px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .btn:hover {
            background: #45a049;
        }

        #tool-panel {
            position: fixed;
            bottom: 16.08px;
            left: 50%;
            transform: translateX(-50%) scale(0.804);
            transform-origin: bottom center;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            transition: all 0.3s;
            padding: 0;
            overflow: visible;
        }

        #tool-icons {
            display: flex;
            padding: 7px 14px;
            align-items: center;
            position: relative;
            justify-content: space-evenly;
            min-width: 350px; 
        }

        .tool-icon {
            font-size: 19px;
            cursor: pointer;
            padding: 5px;
            border-radius: 8px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-icon:hover:not(.active) {
            background: rgba(255, 255, 255, 0.8);
        }

        .tool-icon::before {
            display: none;
        }

        .tool-icon::after {
            content: attr(data-tooltip);
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 10000;
        }

        .tool-icon:hover:not(.active)::after {
            opacity: 1;
        }

        .tool-options-popup {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            visibility: hidden;
            opacity: 0;
            min-width: 250px;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 1000;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 7px;
            padding: 0;
        }

        .tool-options-popup.show {
            visibility: visible;
            opacity: 1;
            padding: 10px 14px;
        }

        .tool-separator {
            width: 2px;
            height: 20px;
            background: rgba(68, 68, 68, 0.5);
        }

        .help-icon {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 18px;
            height: 18px;
            background: #999;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            z-index: 10;
            grid-column: auto;
        }

        .help-icon::after {
            content: attr(data-hint);
            position: absolute;
            bottom: calc(100% + 8px);
            right: 0;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            font-weight: normal;
        }

        .help-icon:hover::after {
            opacity: 1;
        }
        
        .option-group label {
            font-size: 10px;
            margin-bottom: 3px;
        }

        .option-group select,
        .option-group input[type="number"],
        .option-group input[type="text"],
        .option-group input[type="range"] {
            width: 100%;
            padding: 3px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 10px;
        }

        .color-picker {
            display: flex;
            align-items: center;
        }

        .color-picker input[type="color"] {
            width: 30px;
            height: 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #hint {
            position: fixed;
            bottom: 64.32px;
            left: 50%;
            transform: translateX(-50%) scale(0.804);
            transform-origin: bottom center;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 7px 14px;
            border-radius: 5px;
            display: none;
            z-index: 998;
        }

        #text-to-marker-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.804);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 2000;
            min-width: 500px;
            max-width: 700px;
            display: none;
        }

        #text-to-marker-panel.show {
            display: block;
        }

        .text-to-marker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .text-to-marker-header h3 {
            margin: 0;
            color: #333;
        }

        .close-text-to-marker {
            cursor: pointer;
            font-size: 20px;
            color: #999;
        }

        #text-to-marker-input {
            width: 100%;
            min-height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 13px;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            resize: vertical;
        }

        .text-to-marker-example {
            margin: 10px 0;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            font-size: 12px;
            color: #666;
        }

        .text-to-marker-options {
            margin: 15px 0;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .text-to-marker-options label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
        }

        .text-to-marker-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .text-to-marker-buttons button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .text-to-marker-buttons .btn-parse {
            background: #4CAF50;
            color: white;
        }

        .text-to-marker-buttons .btn-parse:hover {
            background: #45a049;
        }

        .text-to-marker-buttons .btn-cancel {
            background: #f44336;
            color: white;
        }

        .text-to-marker-buttons .btn-cancel:hover {
            background: #d32f2f;
        }

        #layers-panel {
            position: fixed;
            left: 16.08px;
            top: 16.08px;
            width: 280px;
            max-height: calc(100vh - 400px);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: scale(0.804);
            transform-origin: top left;
        }

        .layers-header {
            padding: 12px 15px;
            background: rgba(102, 102, 102, 0.1);
            border-bottom: 1px solid rgba(0,0,0,0.1);
            font-weight: bold;
            font-size: 14px;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .layers-content {
            overflow-y: auto;
            flex: 1;
            padding: 10px;
        }

        .layer-section {
            margin-bottom: 15px;
        }

        .layer-section-title {
            font-size: 12px;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
            padding: 5px 8px;
            background: rgba(0,0,0,0.05);
            border-radius: 4px;
        }

        .layer-item {
            padding: 8px 10px;
            margin-bottom: 5px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .layer-item:hover {
            background: #f5f5f5;
            border-color: #4CAF50;
        }

        .layer-item-info {
            flex: 1;
            overflow: hidden;
        }

        .layer-item-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-item-date {
            color: #999;
            font-size: 10px;
        }

        .layer-item-actions {
            display: flex;
            gap: 5px;
        }

        .layer-action-btn {
            padding: 3px 8px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            transition: background 0.2s;
        }

        .layer-action-btn:hover {
            background: #d32f2f;
        }

        .layer-action-btn.toggle {
            background: #4CAF50;
        }

        .layer-action-btn.toggle.hidden {
            background: #999;
        }

        .geojson-upload {
            margin-bottom: 10px;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 5px;
        }

        .geojson-upload label {
            display: block;
            font-size: 11px;
            color: #333;
            margin-bottom: 5px;
        }

        .geojson-upload input[type="file"] {
            display: none;
        }

        .geojson-upload button {
            width: 100%;
            padding: 8px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .geojson-upload button:hover {
            background: #1976D2;
        }
        
        .custom-marker {
            text-align: center;
            line-height: 1;
        }
        .pin-icon svg, .pushpin-icon svg {
            width: 24px;
            height: 24px;
            display: block;
            margin: auto;
        }
        .dot-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid white;
            background: red;
            margin: auto;
            transform: translateY(-50%);
        }

        .text-box {
            position: absolute;
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #4CAF50;
            min-width: 200px;
            min-height: 100px;
            cursor: move;
            z-index: 500;
        }

        .text-box textarea {
            width: 100%;
            height: 80px;
            border: none;
            resize: none;
            background: transparent;
        }

        .text-box-close {
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
            color: #f44336;
            font-weight: bold;
        }

        #location-panel {
            position: fixed;
            bottom: 64.32px;
            left: 50%;
            transform: translateX(-50%) scale(0.804);
            transform-origin: bottom center;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 999;
            min-width: 400px;
            max-width: 500px;
            display: none;
        }

        .location-select-group {
            margin-bottom: 15px;
        }

        .location-select-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            font-weight: bold;
            color: #333;
        }

        .location-select-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        .location-select-group select:disabled {
            background: #f5f5f5;
            cursor: not-allowed;
            color: #999;
        }

        .result-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s;
        }

        .result-item:hover {
            background: #e3f2fd;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        #file-controls {
            position: fixed;
            top: 16.08px;
            right: 16.08px;
            z-index: 1000;
            display: flex;
            gap: 10px;
            transform: scale(0.804);
            transform-origin: top right;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            padding: 7px 14px; 
            align-items: center;
        }

        .file-icon {
            font-size: 19px;
            cursor: pointer;
            padding: 5px;
            border-radius: 8px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            z-index: 1;
            display: flex; 
            align-items: center;
            justify-content: center;
        }

        .file-icon:hover {
            background: rgba(255, 255, 255, 0.8);
        }
        
        .file-icon::after {
            content: attr(data-tooltip);
            position: absolute;
            top: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 10000;
        }

        .file-icon:hover::after {
            opacity: 1;
        }

        #settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.804);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 2000;
            min-width: 300px;
            display: none;
        }

        #settings-panel.show {
            display: block;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .settings-header h3 {
            margin: 0;
            color: #333;
        }

        .close-settings {
            cursor: pointer;
            font-size: 20px;
            color: #999;
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #666;
        }

        .setting-item input[type="color"] {
            width: 100%;
            height: 40px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
        }

        .setting-item input[type="range"] {
            width: 100%;
        }

        .opacity-value {
            color: #2196F3;
            font-weight: bold;
        }

        .boundary-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        .boundary-controls label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #333;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
            font-size: 12px;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="hint"></div>

    <!-- 左侧图层面板 -->
    <div id="layers-panel">
        <div class="layers-header">
            <span>图层管理</span>
            <span style="cursor: pointer; font-size: 16px;" id="toggle-layers">▼</span>
        </div>
        <div class="layers-content">
            <!-- 边界图层 -->
            <div class="layer-section">
                <div class="layer-section-title">边界图层 (<span id="boundary-count">0</span>)</div>
                <div id="boundary-layers-list"></div>
            </div>

            <!-- 事件图层 -->
            <div class="layer-section">
                <div class="layer-section-title">事件 (<span id="event-count">0</span>)</div>
                <div id="event-layers-list"></div>
            </div>

            <!-- 标记图层 -->
            <div class="layer-section">
                <div class="layer-section-title">标记 (<span id="marker-count">0</span>)</div>
                <div id="marker-layers-list"></div>
            </div>

            <!-- 线条图层 -->
            <div class="layer-section">
                <div class="layer-section-title">线条/箭头 (<span id="line-count">0</span>)</div>
                <div id="line-layers-list"></div>
            </div>

            <!-- 文本图层 -->
            <div class="layer-section">
                <div class="layer-section-title">文本框 (<span id="text-count">0</span>)</div>
                <div id="text-layers-list"></div>
            </div>
        </div>
    </div>

    <div id="zoom-control">
        <div id="zoom-slider-container">
            <div id="zoom-slider-track"></div>
            <div id="zoom-slider-thumb"></div>
        </div>
        <div id="zoom-levels"></div>
    </div>

    <div id="date-selector">
        <div id="date-display">当前日期: 2025-01-01</div>
        <div id="calendar-container">
            <div class="calendar-header">
                <button id="prev-month">◀</button>
                <div>
                    <select id="year-select"></select>
                    <select id="month-select">
                        <option value="0">1月</option>
                        <option value="1">2月</option>
                        <option value="2">3月</option>
                        <option value="3">4月</option>
                        <option value="4">5月</option>
                        <option value="5">6月</option>
                        <option value="6">7月</option>
                        <option value="7">8月</option>
                        <option value="8">9月</option>
                        <option value="9">10月</option>
                        <option value="10">11月</option>
                        <option value="11">12月</option>
                    </select>
                </div>
                <button id="next-month">▶</button>
            </div>
            <div class="calendar-weekdays">
                <div class="calendar-day-header">日</div>
                <div class="calendar-day-header">一</div>
                <div class="calendar-day-header">二</div>
                <div class="calendar-day-header">三</div>
                <div class="calendar-day-header">四</div>
                <div class="calendar-day-header">五</div>
                <div class="calendar-day-header">六</div>
            </div>
            <div class="calendar-grid" id="calendar-days"></div>
        </div>
    </div>

    <div id="tool-panel">
        <div id="tool-icons">
            <div class="tool-icon active" data-tool="pan" data-tooltip="平移地图">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 11l3-3m0 0l3 3m-3-3v8m0-13a9 9 0 110 18 9 9 0 010-18z"/>
                </svg>
            </div>
            <div class="tool-separator"></div>
            
            <div class="tool-icon" data-tool="annotate" data-tooltip="添加标记/绘制线条">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                </svg>
            </div>

            <div class="tool-icon" data-tool="text" data-tooltip="添加文本">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 7V4h16v3M9 20h6M12 4v16"/>
                </svg>
            </div>
            <div class="tool-separator"></div>
            <div class="tool-icon" data-tool="location" data-tooltip="位置搜索">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/><path d="M2 12h20M12 2a15.3 15.3 0 014 10 15.3 15.3 0 01-4 10 15.3 15.3 0 01-4-10 15.3 15.3 0 014-10z"/>
                </svg>
            </div>
            <div class="tool-separator"></div>
            <div class="tool-icon" data-tool="eraser" data-tooltip="擦除标注">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 4l6 6-8 8-6-6 8-8zM5 16l-3 3h10"/>
                </svg>
            </div>
            <div class="tool-icon" data-tool="clear" data-tooltip="清空全部">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 6h18M8 6V4h8v2m-9 4v10h10V10M10 14h4"/>
                </svg>
            </div>
            <div class="tool-separator"></div>
            <div class="tool-icon" data-tool="text-to-marker" data-tooltip="文本转标识">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/>
                    <path d="M14 2v6h6M16 13H8m8 4H8m2-8H8"/>
                    <circle cx="18" cy="18" r="3"/>
                    <path d="M18 16v4m-2-2h4"/>
                </svg>
            </div>
        </div>
    </div>

    <div id="location-panel">
        <h3 style="margin: 0 0 15px 0; color: #333; font-size: 16px;">位置搜索</h3>
        
        <!-- 加载数据库按钮 -->
        <div style="margin-bottom: 15px; padding: 10px; background: #f0f0f0; border-radius: 5px;">
            <label style="display: block; margin-bottom: 5px; font-size: 13px; color: #333;">批量加载数据文件:</label>
            <input type="file" id="db-file-input" accept=".json,.geojson" multiple style="display: none;">
            <button class="btn" id="load-db-btn" style="width: 100%;">选择JSON文件（可多选）</button>
            <div id="db-status" style="margin-top: 5px; font-size: 11px; color: #666; text-align: center;"></div>
        </div>
        
        <!-- 四级联动下拉菜单 -->
        <div class="location-select-group">
            <label>国家</label>
            <select id="country-select" disabled>
                <option value="">请先加载数据库</option>
            </select>
        </div>
        <div class="location-select-group">
            <label>州/省</label>
            <select id="state-select" disabled>
                <option value="">请先选择国家</option>
            </select>
        </div>
        <div class="location-select-group">
            <label>城市</label>
            <select id="city-select" disabled>
                <option value="">请先选择州/省</option>
            </select>
        </div>
        <button class="btn" id="go-location-btn" disabled style="width:100%; margin-bottom: 15px;">定位</button>
        
        <!-- 或者直接搜索 -->
        <div style="border-top: 1px solid #ddd; padding-top: 15px;">
            <label style="display: block; margin-bottom: 5px; font-size: 13px; font-weight: bold; color: #333;">或直接搜索:</label>
            <input type="text" id="address-search-input" placeholder="输入国家、州/省或城市名..." style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 5px; font-size: 14px; margin-bottom: 10px;">
            <button class="btn" id="search-address-btn" disabled style="width:100%; margin-bottom: 10px;">搜索</button>
        </div>
        
        <div id="search-results" style="max-height: 300px; overflow-y: auto; margin-bottom: 10px; display: none;">
            <label style="display: block; margin-bottom: 5px; font-size: 13px; font-weight: bold; color: #333;">搜索结果:</label>
            <div id="results-list" style="background: white; border: 1px solid #ddd; border-radius: 5px; max-height: 250px; overflow-y: auto;"></div>
        </div>
        
        <!-- 边界控制 -->
        <div class="boundary-controls">
            <label class="checkbox-label">
                <input type="checkbox" id="show-boundaries-checkbox" checked>
                显示行政区划边界
            </label>
            <div id="boundary-status" style="margin-top: 5px; font-size: 11px; color: #666; text-align: center;"></div>
        </div>
        
        <div id="search-status" style="margin-top: 10px; font-size: 12px; color: #666; text-align: center;"></div>
    </div>

    <div id="file-controls">
        <div class="file-icon" id="save-btn" data-tooltip="保存">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"/>
                <path d="M17 21v-8H7v8M7 3v5h8"/>
            </svg>
        </div>
        <div class="file-icon" id="load-btn" data-tooltip="加载">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M13 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V9z"/>
                <path d="M13 2v7h7"/>
            </svg>
        </div>
        <div class="tool-separator"></div>
        <div class="file-icon" id="settings-btn" data-tooltip="设置">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="3"/>
                <path d="M12 1v6m0 6v6M4.22 4.22l4.24 4.24m5.08 5.08l4.24 4.24M1 12h6m6 0h6M4.22 19.78l4.24-4.24m5.08-5.08l4.24-4.24"/>
            </svg>
        </div>
        <input type="file" id="file-input" style="display:none;" accept=".json">
    </div>

    <div id="settings-panel">
        <div class="settings-header">
            <h3>主题设置</h3>
            <span class="close-settings">✕</span>
        </div>
        <div class="setting-item">
            <label>按钮颜色</label>
            <input type="color" id="theme-button-color" value="#666666">
        </div>
        <div class="setting-item">
            <label>框内填充颜色</label>
            <input type="color" id="theme-fill-color" value="#ffffff">
        </div>
        <div class="setting-item">
            <label>填充不透明度: <span class="opacity-value" id="fill-opacity-value">50%</span></label>
            <input type="range" id="theme-fill-opacity" min="0" max="100" value="50">
        </div>
    </div>

    <div id="text-to-marker-panel">
        <div class="text-to-marker-header">
            <h3>文本转标识</h3>
            <span class="close-text-to-marker">✕</span>
        </div>
        <div class="text-to-marker-example">
            格式示例：事件名称；时间；地点一；关系；地点二<br>
            例如：俄乌冲突；2022-02-24；Ukraine；invasion；Russia<br>
            可以输入多段，每段一行
        </div>
        <textarea id="text-to-marker-input" placeholder="请输入事件信息...&#10;格式：事件名称；时间；地点一；关系；地点二&#10;可多行输入"></textarea>
        <div class="text-to-marker-options">
            <label>
                <input type="checkbox" id="option-show-boundaries" checked>
                显示边界
            </label>
            <label>
                <input type="radio" name="arrow-type" value="line" checked>
                直线
            </label>
            <label>
                <input type="radio" name="arrow-type" value="dashed">
                虚线
            </label>
            <label>
                <input type="radio" name="arrow-type" value="arrow">
                箭头
            </label>
            <label>
                <input type="radio" name="arrow-type" value="chevron">
                雪佛龙箭头
            </label>
        </div>
        <div class="text-to-marker-buttons">
            <button class="btn-parse">解析并生成</button>
            <button class="btn-cancel">取消</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            
            const map = L.map('map', {
                center: [20, 0],
                zoom: 2,
                minZoom: 2,
                maxZoom: 18,
                doubleClickZoom: false,
                worldCopyJump: true,
                maxBounds: [[-85, -Infinity], [85, Infinity]]
            });

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap',
                maxZoom: 18
            }).addTo(map);

            // 边界图层
            let boundaryLayers = L.layerGroup().addTo(map);
            let allBoundaries = []; // 存储所有边界对象

            let currentTool = 'pan';
            let drawingState = {
                isDrawing: false,
                startPoint: null,
                points: [],
                previewLayer: null,
                tempMarker: null,
                dashedSegments: []
            };

            let eraserState = {
                isErasing: false
            };

            let currentDate = new Date(2025, 0, 1); 
            let calendarDate = new Date(2025, 0, 1);

            const dateDisplayEl = document.getElementById('date-display');
            const calendarContainer = document.getElementById('calendar-container');
            const yearSelect = document.getElementById('year-select');
            const monthSelect = document.getElementById('month-select');
            const prevMonthBtn = document.getElementById('prev-month');
            const nextMonthBtn = document.getElementById('next-month');
            const calendarDays = document.getElementById('calendar-days');
            
            const toolOptions = {
                annotate: { 
                    markerType: 'none',
                    lineStyle: 'solid',
                    lineType: 'straight',
                    color: '#ff0000',
                    weight: 3,
                    opacity: 1,
                    arrowText: ''
                },
                text: { bgColor: '#ffffff', textColor: '#000000', opacity: 1 }
            };

            const annotations = {
                markers: [],
                lines: [],
                arrows: [],
                textBoxes: [],
                events: [] // 新增：事件数据
            };

            let locationState = {
                currentLocation: null
            };

            let geoDatabase = [];
            let databaseLoaded = false;
            let localGeoJSONFiles = {}; // 存储本地GeoJSON文件 {name: geojsonData}

            function showSearchStatus(message, isError = false) {
                const statusEl = document.getElementById('search-status');
                if (statusEl) {
                    statusEl.textContent = message;
                    statusEl.style.color = isError ? '#f44336' : '#666';
                }
            }

            function showDbStatus(message, isError = false) {
                const statusEl = document.getElementById('db-status');
                if (statusEl) {
                    statusEl.textContent = message;
                    statusEl.style.color = isError ? '#f44336' : '#4CAF50';
                }
            }

            function showBoundaryStatus(message, isError = false) {
                const statusEl = document.getElementById('boundary-status');
                if (statusEl) {
                    statusEl.textContent = message;
                    statusEl.style.color = isError ? '#f44336' : '#4CAF50';
                }
            }

            // 英文省份名到中文的映射
            const provinceNameMap = {
                'beijing': '北京',
                'tianjin': '天津',
                'hebei': '河北',
                'shanxi': '山西',
                'inner mongolia': '内蒙古',
                'liaoning': '辽宁',
                'jilin': '吉林',
                'heilongjiang': '黑龙江',
                'shanghai': '上海',
                'jiangsu': '江苏',
                'zhejiang': '浙江',
                'anhui': '安徽',
                'fujian': '福建',
                'jiangxi': '江西',
                'shandong': '山东',
                'henan': '河南',
                'hubei': '湖北',
                'hunan': '湖南',
                'guangdong': '广东',
                'guangxi': '广西',
                'hainan': '海南',
                'chongqing': '重庆',
                'sichuan': '四川',
                'guizhou': '贵州',
                'yunnan': '云南',
                'tibet': '西藏',
                'shaanxi': '陕西',
                'gansu': '甘肃',
                'qinghai': '青海',
                'ningxia': '宁夏',
                'xinjiang': '新疆',
                'taiwan': '台湾',
                'hongkong': '香港',
                'hong kong': '香港',
                'macau': '澳门',
                'macao': '澳门'
            };

            // 从中国GeoJSON中提取特定区域的边界
            function extractChinaRegionBoundary(geojsonData, regionName, regionType) {
                console.log(`尝试提取区域: ${regionName}, 类型: ${regionType}`);
                
                if (!geojsonData || !geojsonData.features) {
                    console.error('GeoJSON数据格式不正确');
                    return null;
                }
                
                // 规范化搜索名称
                let searchNames = [regionName];
                const regionNameLower = regionName.toLowerCase();
                
                // 如果是英文名，添加对应的中文名
                if (provinceNameMap[regionNameLower]) {
                    searchNames.push(provinceNameMap[regionNameLower]);
                    searchNames.push(provinceNameMap[regionNameLower] + '省');
                    searchNames.push(provinceNameMap[regionNameLower] + '市');
                }
                
                // 也添加去掉"省"、"市"、"自治区"后缀的版本
                searchNames.push(regionName.replace(/[省市自治区]/g, ''));
                
                console.log('搜索名称列表:', searchNames);
                
                // 查找匹配的Feature
                const feature = geojsonData.features.find(f => {
                    const properties = f.properties || {};
                    const name = properties.name || properties.NAME || properties.名称 || '';
                    
                    // 尝试多种属性名称
                    const possibleNames = [
                        name,
                        properties.NAME_CHN,
                        properties.province,
                        properties.city,
                        properties.adcode99,
                        properties.省,
                        properties.市,
                        properties.NL_NAME_1,
                        properties.NAME_1
                    ].filter(Boolean);
                    
                    // 检查是否匹配任何搜索名称
                    return searchNames.some(searchName => {
                        return possibleNames.some(pName => {
                            const pNameStr = String(pName).toLowerCase();
                            const searchNameLower = searchName.toLowerCase();
                            
                            // 完全匹配
                            if (pNameStr === searchNameLower) return true;
                            
                            // 包含匹配
                            if (pNameStr.includes(searchNameLower)) return true;
                            if (searchNameLower.includes(pNameStr)) return true;
                            
                            // 去掉省市后缀再匹配
                            const pNameClean = pNameStr.replace(/[省市自治区]/g, '');
                            const searchNameClean = searchNameLower.replace(/[省市自治区]/g, '');
                            if (pNameClean === searchNameClean) return true;
                            
                            return false;
                        });
                    });
                });
                
                if (feature) {
                    console.log('找到匹配的区域:', feature.properties);
                    // 返回单个Feature作为新的GeoJSON
                    return {
                        type: 'FeatureCollection',
                        features: [feature]
                    };
                } else {
                    console.warn(`未找到区域: ${regionName}`);
                    console.log('可用的区域:', geojsonData.features.slice(0, 10).map(f => 
                        f.properties?.name || f.properties?.NAME || '未知'
                    ));
                    console.log('总共有', geojsonData.features.length, '个区域');
                    return null;
                }
            }
            
            // 从本地或API获取边界
            async function fetchBoundaryFromNominatim(location) {
                try {
                    const locationNameLower = (location.displayName || location.name).toLowerCase();
                    
                    // 检查是否是中国相关查询
                    const isChinaQuery = locationNameLower.includes('china') || 
                                        locationNameLower.includes('中国') ||
                                        locationNameLower.includes('中华人民共和国');
                    
                    // 检查是否是中国的省份或城市查询
                    const isChinaRegion = location.parentCountry === 'China' || 
                                         location.country === 'China' ||
                                         (location.type === 'state' || location.type === 'city') && 
                                         (location.displayName?.includes('中国') || location.countryName === 'China');
                    
                    if (isChinaQuery || isChinaRegion) {
                        console.log('检测到中国查询，使用本地GeoJSON文件');
                        console.log('位置信息:', location);
                        console.log('可用的本地文件:', Object.keys(localGeoJSONFiles));
                        
                        // 查找本地中国GeoJSON文件
                        const chinaKey = Object.keys(localGeoJSONFiles).find(key => {
                            const keyLower = key.toLowerCase();
                            return keyLower.includes('china') || 
                                   key.includes('中国') ||
                                   key.includes('中华人民共和国');
                        });
                        
                        if (chinaKey) {
                            console.log('找到本地中国文件:', chinaKey);
                            showBoundaryStatus('使用本地中国边界文件...');
                            
                            let geojsonData = localGeoJSONFiles[chinaKey];
                            let boundaryName = '中华人民共和国';
                            let isFullChina = true;
                            
                            // 如果是省份或城市，提取特定区域
                            if (location.type === 'state' || location.type === 'city') {
                                const regionName = location.name;
                                const extractedRegion = extractChinaRegionBoundary(
                                    geojsonData, 
                                    regionName, 
                                    location.type
                                );
                                
                                if (extractedRegion) {
                                    geojsonData = extractedRegion;
                                    boundaryName = regionName;
                                    isFullChina = false;
                                    console.log('成功提取区域边界:', regionName);
                                } else {
                                    // 如果找不到特定区域，显示整个中国
                                    console.warn('未找到特定区域，显示整个中国边界');
                                    showBoundaryStatus('未找到该区域边界，显示整个中国', true);
                                }
                            }
                            
                            // 创建图层，根据是否是完整中国来决定样式
                            const layer = L.geoJSON(geojsonData, {
                                style: function(feature) {
                                    if (isFullChina) {
                                        // 完整中国：只显示外轮廓，不显示内部省界
                                        return {
                                            color: '#ff0000',
                                            weight: 2,
                                            opacity: 0.8,
                                            fillColor: '#ff0000',
                                            fillOpacity: 0.1,
                                            // 关键：使用stroke来只显示外边界
                                            fill: true
                                        };
                                    } else {
                                        // 单个省份：显示边界
                                        return {
                                            color: '#ff0000',
                                            weight: 2,
                                            opacity: 0.8,
                                            fillColor: '#ff0000',
                                            fillOpacity: 0.1
                                        };
                                    }
                                },
                                // 对于完整中国，合并所有features为一个整体
                                onEachFeature: isFullChina ? null : undefined
                            });
                            
                            const boundaryObj = {
                                name: boundaryName,
                                layer: layer,
                                visible: true,
                                type: 'local'
                            };
                            
                            allBoundaries.push(boundaryObj);
                            
                            const showCheckbox = document.getElementById('show-boundaries-checkbox');
                            if (showCheckbox && showCheckbox.checked) {
                                boundaryLayers.addLayer(layer);
                            }
                            
                            updateLayersPanel();
                            showBoundaryStatus('✓ 本地边界加载成功');
                            
                            setTimeout(() => {
                                showBoundaryStatus('');
                            }, 3000);
                            
                            return layer;
                        } else {
                            // 没有找到本地文件，不调用API，提示用户
                            console.error('未找到本地中国GeoJSON文件');
                            showBoundaryStatus('请先上传中国GeoJSON边界文件', true);
                            alert('未找到中国边界文件！\n\n请在"批量加载数据文件"处上传包含中国边界的GeoJSON文件。\n文件名应包含"中国"、"中华人民共和国"或"china"。');
                            setTimeout(() => {
                                showBoundaryStatus('');
                            }, 5000);
                            return null;
                        }
                    }
                    
                    // 非中国查询，使用API
                    showBoundaryStatus('正在加载边界数据...');
                    
                    let query = location.displayName || location.name;
                    
                    const searchUrl = `https://nominatim.openstreetmap.org/search?` + 
                        `q=${encodeURIComponent(query)}&` +
                        `format=json&` +
                        `polygon_geojson=1&` +
                        `limit=1`;
                    
                    const response = await fetch(searchUrl, {
                        headers: {
                            'User-Agent': 'WorldSituationMap/1.0'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error('API 请求失败');
                    }
                    
                    const data = await response.json();
                    
                    if (data && data.length > 0 && data[0].geojson) {
                        const geojson = data[0].geojson;
                        
                        const layer = L.geoJSON(geojson, {
                            style: {
                                color: '#ff0000',
                                weight: 2,
                                opacity: 0.8,
                                fillColor: '#ff0000',
                                fillOpacity: 0.1
                            }
                        });
                        
                        const boundaryObj = {
                            name: location.displayName || location.name,
                            layer: layer,
                            visible: true,
                            type: location.type || 'unknown'
                        };
                        
                        allBoundaries.push(boundaryObj);
                        
                        const showCheckbox = document.getElementById('show-boundaries-checkbox');
                        if (showCheckbox && showCheckbox.checked) {
                            boundaryLayers.addLayer(layer);
                        }
                        
                        updateLayersPanel();
                        showBoundaryStatus('✓ 边界加载成功');
                        
                        setTimeout(() => {
                            showBoundaryStatus('');
                        }, 3000);
                        
                        return layer;
                    } else {
                        showBoundaryStatus('该地区暂无边界数据', true);
                        setTimeout(() => {
                            showBoundaryStatus('');
                        }, 3000);
                        return null;
                    }
                } catch (error) {
                    console.error('获取边界失败:', error);
                    showBoundaryStatus('边界加载失败', true);
                    setTimeout(() => {
                        showBoundaryStatus('');
                    }, 3000);
                    return null;
                }
            }

            // 获取多个边界并合并显示
            async function fetchMultipleBoundaries(locationNames) {
                try {
                    showBoundaryStatus('正在加载边界数据...');
                    
                    for (const name of locationNames) {
                        const searchUrl = `https://nominatim.openstreetmap.org/search?` + 
                            `q=${encodeURIComponent(name)}&` +
                            `format=json&` +
                            `polygon_geojson=1&` +
                            `limit=1`;
                        
                        try {
                            const response = await fetch(searchUrl, {
                                headers: {
                                    'User-Agent': 'WorldSituationMap/1.0'
                                }
                            });
                            
                            if (response.ok) {
                                const data = await response.json();
                                if (data && data.length > 0 && data[0].geojson) {
                                    const layer = L.geoJSON(data[0].geojson, {
                                        style: {
                                            color: '#ff0000',
                                            weight: 2,
                                            opacity: 0.8,
                                            fillColor: '#ff0000',
                                            fillOpacity: 0.1
                                        }
                                    });
                                    
                                    const boundaryObj = {
                                        name: name,
                                        layer: layer,
                                        visible: true,
                                        type: 'region'
                                    };
                                    
                                    allBoundaries.push(boundaryObj);
                                    
                                    const showCheckbox = document.getElementById('show-boundaries-checkbox');
                                    if (showCheckbox && showCheckbox.checked) {
                                        boundaryLayers.addLayer(layer);
                                    }
                                }
                            }
                            
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            
                        } catch (error) {
                            console.error(`获取 ${name} 边界失败:`, error);
                        }
                    }
                    
                    if (allBoundaries.length > 0) {
                        updateLayersPanel();
                        showBoundaryStatus(`✓ 已加载完整边界`);
                        
                        setTimeout(() => {
                            showBoundaryStatus('');
                        }, 3000);
                    } else {
                        showBoundaryStatus('未找到边界数据', true);
                        setTimeout(() => {
                            showBoundaryStatus('');
                        }, 3000);
                    }
                    
                } catch (error) {
                    console.error('获取边界失败:', error);
                    showBoundaryStatus('边界加载失败', true);
                    setTimeout(() => {
                        showBoundaryStatus('');
                    }, 3000);
                }
            }

            // 边界显示控制
            document.getElementById('show-boundaries-checkbox').addEventListener('change', function() {
                if (this.checked) {
                    allBoundaries.forEach(b => {
                        if (b.visible && b.layer) {
                            boundaryLayers.addLayer(b.layer);
                        }
                    });
                } else {
                    boundaryLayers.clearLayers();
                }
            });

            // 文本转标识功能
            function initTextToMarker() {
                const textToMarkerBtn = document.querySelector('[data-tool="text-to-marker"]');
                const panel = document.getElementById('text-to-marker-panel');
                const closeBtn = document.querySelector('.close-text-to-marker');
                const cancelBtn = document.querySelector('.btn-cancel');
                const parseBtn = document.querySelector('.btn-parse');
                const textInput = document.getElementById('text-to-marker-input');

                if (!textToMarkerBtn) return;

                // 打开面板
                textToMarkerBtn.addEventListener('click', () => {
                    panel.classList.add('show');
                });

                // 关闭面板
                closeBtn.addEventListener('click', () => {
                    panel.classList.remove('show');
                });

                cancelBtn.addEventListener('click', () => {
                    panel.classList.remove('show');
                });

                // 解析并生成
                parseBtn.addEventListener('click', async () => {
                    const text = textInput.value.trim();
                    if (!text) {
                        alert('请输入事件信息');
                        return;
                    }

                    const showBoundaries = document.getElementById('option-show-boundaries').checked;
                    const arrowType = document.querySelector('input[name="arrow-type"]:checked').value;

                    // 解析文本
                    const events = parseEventsText(text);
                    if (events.length === 0) {
                        alert('未能解析任何事件，请检查格式');
                        return;
                    }

                    // 处理每个事件
                    for (const event of events) {
                        await processEvent(event, showBoundaries, arrowType);
                    }

                    panel.classList.remove('show');
                    textInput.value = '';
                    updateLayersPanel();
                    alert(`成功生成 ${events.length} 个事件`);
                });
            }

            // 解析事件文本
            function parseEventsText(text) {
                const lines = text.split('\n').filter(line => line.trim());
                const events = [];

                for (const line of lines) {
                    const parts = line.split(/[；;]/).map(p => p.trim());
                    if (parts.length === 5) {
                        events.push({
                            name: parts[0],
                            time: parts[1],
                            location1: parts[2],
                            relation: parts[3],
                            location2: parts[4]
                        });
                    }
                }

                return events;
            }

            // 处理单个事件
            async function processEvent(event, showBoundaries, arrowType) {
                console.log('处理事件:', event);

                // 搜索地点坐标
                const loc1 = await searchLocation(event.location1);
                const loc2 = await searchLocation(event.location2);
                console.log("loc1 坐标:", event.location1, loc1);
                console.log("loc2 坐标:", event.location2, loc2);


                if (!loc1 || !loc2) {
                    console.error('无法找到地点坐标:', event);
                    alert(`无法找到地点: ${!loc1 ? event.location1 : event.location2}`);
                    return;
                }

                const eventData = {
                    name: event.name,
                    time: event.time,
                    location1: event.location1,
                    relation: event.relation,
                    location2: event.location2,
                    loc1Coords: loc1,
                    loc2Coords: loc2,
                    date: new Date(currentDate),
                    boundaries: [],
                    connections: []
                };

                // 添加边界
                if (showBoundaries) {
                    const boundary1 = await fetchBoundaryFromNominatim({
                        name: event.location1,
                        displayName: event.location1,
                        type: loc1.type
                    });
                    if (boundary1) {
                        eventData.boundaries.push({
                            location: event.location1,
                            layer: boundary1
                        });
                    }

                    await new Promise(resolve => setTimeout(resolve, 1000));

                    const boundary2 = await fetchBoundaryFromNominatim({
                        name: event.location2,
                        displayName: event.location2,
                        type: loc2.type
                    });
                    if (boundary2) {
                        eventData.boundaries.push({
                            location: event.location2,
                            layer: boundary2
                        });
                    }
                }
                // 创建连接线 - 为两点添加中间控制点
                const midLat = (loc1.latitude + loc2.latitude) / 2;
                const midLng = (loc1.longitude + loc2.longitude) / 2;
                
                // 计算垂直偏移，创建弧形
                const latDiff = loc2.latitude - loc1.latitude;
                const lngDiff = loc2.longitude - loc1.longitude;
                const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
                const offset = distance * 0.001; // 偏移量为距离的30%
                
                // 垂直于连线方向的偏移
                const perpLat = -lngDiff / distance * offset;
                const perpLng = latDiff / distance * offset;
                
                const points = [
                    L.latLng(loc1.latitude, loc1.longitude),
                    L.latLng(midLat + perpLat, midLng + perpLng), // 中间控制点
                    L.latLng(loc2.latitude, loc2.longitude)
                ];

                const lineOptions = {
                    lineType: 'bezier',
                    color: '#ff0000',
                    weight: 3,
                    opacity: 1,
                    arrowText: event.relation
                };

                let connectionLayer;
                if (arrowType === 'line') {
                    lineOptions.lineStyle = 'solid';
                    connectionLayer = createLine(points, lineOptions);
                    eventData.connections.push({
                        layer: connectionLayer,
                        type: 'line'
                    });
                } else if (arrowType === 'dashed') {
                    lineOptions.lineStyle = 'dashed';
                    connectionLayer = createLine(points, lineOptions);
                    eventData.connections.push({
                        layer: connectionLayer,
                        type: 'line'
                    });
                } else if (arrowType === 'arrow') {
                    const arrow = createArrow(points, lineOptions);
                    arrow.layer.addTo(map);
                    eventData.connections.push(arrow);
                } else if (arrowType === 'chevron') {
                    const chevron = createChevron(points, lineOptions, map);
                    chevron.layer.addTo(map);
                    eventData.connections.push(chevron);
                }

                // 如果是line或dashed，添加到地图
                if (arrowType === 'line' || arrowType === 'dashed') {
                    eventData.connections[0].layer.addTo(map);
                }

                annotations.events.push(eventData);
            }
// 搜索地点坐标 (新版本，支持层级搜索)
            async function searchLocation(locationName) {
                if (!databaseLoaded) {
                    console.error('数据库未加载');
                    return null;
                }

                // 1. 将搜索字符串按逗号分割，并清理空格和转换为小写
                const parts = locationName.split(',').map(p => p.trim().toLowerCase());
                
                // 2. 处理三段式搜索: "国家, 省份, 城市"
                if (parts.length === 3) {
                    const [countryName, stateName, cityName] = parts;
                    const country = geoDatabase.find(c => c.name.toLowerCase() === countryName);
                    if (country?.states) {
                        const state = country.states.find(s => s.name.toLowerCase() === stateName);
                        if (state?.cities) {
                            const city = state.cities.find(c => c.name.toLowerCase() === cityName);
                            if (city) {
                                console.log(`Found City: ${city.name} in ${state.name}, ${country.name}`);
                                return { latitude: parseFloat(city.latitude), longitude: parseFloat(city.longitude), type: 'city', zoom: 11 };
                            }
                        }
                    }
                }

                // 3. 处理两段式搜索: "国家, 省份" 或 "省份, 城市"
                if (parts.length === 2) {
                    const [parentName, childName] = parts;

                    // 优先尝试 "国家, 省份"
                    const countryAsParent = geoDatabase.find(c => c.name.toLowerCase() === parentName);
                    if (countryAsParent?.states) {
                        const state = countryAsParent.states.find(s => s.name.toLowerCase() === childName);
                        if (state) {
                             console.log(`Found State: ${state.name} in ${countryAsParent.name}`);
                            return { latitude: parseFloat(state.latitude), longitude: parseFloat(state.longitude), type: 'state', zoom: 7 };
                        }
                    }

                    // 如果找不到，则在所有数据中尝试 "省份, 城市"
                    for (const country of geoDatabase) {
                        if (country.states) {
                            const stateAsParent = country.states.find(s => s.name.toLowerCase() === parentName);
                            if (stateAsParent?.cities) {
                                const city = stateAsParent.cities.find(c => c.name.toLowerCase() === childName);
                                if (city) {
                                    console.log(`Found City: ${city.name} in ${stateAsParent.name}`);
                                    return { latitude: parseFloat(city.latitude), longitude: parseFloat(city.longitude), type: 'city', zoom: 11 };
                                }
                            }
                        }
                    }
                }

                // 4. 处理单段式搜索: "国家" 或 "省份"
                if (parts.length === 1) {
                    const searchTerm = parts[0];
                    
                    // 优先进行精确的国家名称匹配
                    const country = geoDatabase.find(c => c.name.toLowerCase() === searchTerm);
                    if (country) {
                        console.log(`Found Country: ${country.name}`);
                        return { latitude: parseFloat(country.latitude), longitude: parseFloat(country.longitude), type: 'country', zoom: 5 };
                    }

                    // 如果不是国家，再精确匹配省份名称
                    for (const c of geoDatabase) {
                        if (c.states) {
                            const state = c.states.find(s => s.name.toLowerCase() === searchTerm);
                            if (state) {
                                console.log(`Found State: ${state.name}`);
                                return { latitude: parseFloat(state.latitude), longitude: parseFloat(state.longitude), type: 'state', zoom: 7 };
                            }
                        }
                    }
                }

                // 5. 如果所有精确搜索都失败，则返回 null
                console.warn(`'${locationName}' could not be found with a structured search. Returning null.`);
                return null;
            }
            // 删除事件
            function deleteEvent(eventIndex) {
                const event = annotations.events[eventIndex];
                
                // 删除边界
                event.boundaries.forEach(b => {
                    if (b.layer) {
                        boundaryLayers.removeLayer(b.layer);
                        allBoundaries = allBoundaries.filter(ab => ab.layer !== b.layer);
                    }
                });

                // 删除连接线
                event.connections.forEach(c => {
                    if (c.layer) {
                        map.removeLayer(c.layer);
                    }
                });

                annotations.events.splice(eventIndex, 1);
                updateLayersPanel();
            }

            // GeoJSON文件上传功能
            function initGeoJSONUpload() {
                const uploadBtn = document.getElementById('upload-geojson-btn');
                const fileInput = document.getElementById('geojson-file-input');
                
                // 功能已移除，保留空函数避免错误
                if (!uploadBtn || !fileInput) return;

                uploadBtn.addEventListener('click', () => {
                    fileInput.click();
                });

                fileInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = function(event) {
                        try {
                            const geojsonData = JSON.parse(event.target.result);
                            
                            const layer = L.geoJSON(geojsonData, {
                                style: {
                                    color: '#2196F3',
                                    weight: 2,
                                    opacity: 0.8,
                                    fillColor: '#2196F3',
                                    fillOpacity: 0.15
                                }
                            });

                            const boundaryObj = {
                                name: file.name.replace('.json', '').replace('.geojson', ''),
                                layer: layer,
                                visible: true,
                                type: 'geojson'
                            };

                            allBoundaries.push(boundaryObj);

                            const showCheckbox = document.getElementById('show-boundaries-checkbox');
                            if (showCheckbox && showCheckbox.checked) {
                                boundaryLayers.addLayer(layer);
                            }

                            map.fitBounds(layer.getBounds());

                            updateLayersPanel();
                            alert('GeoJSON文件加载成功！');
                        } catch (error) {
                            console.error('GeoJSON解析失败:', error);
                            alert('文件格式错误，请选择有效的GeoJSON文件');
                        }
                    };

                    reader.readAsText(file);
                });
            }

            // 更新图层面板
            function updateLayersPanel() {
                // 更新边界列表
                const boundaryList = document.getElementById('boundary-layers-list');
                const boundaryCount = document.getElementById('boundary-count');
                boundaryList.innerHTML = '';
                boundaryCount.textContent = allBoundaries.length;

                allBoundaries.forEach((boundary, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    item.innerHTML = `
                        <div class="layer-item-info">
                            <div class="layer-item-name">${boundary.name}</div>
                            <div class="layer-item-date">${boundary.type}</div>
                        </div>
                        <div class="layer-item-actions">
                            <button class="layer-action-btn toggle ${boundary.visible ? '' : 'hidden'}" data-index="${index}">
                                ${boundary.visible ? '👁' : '👁‍🗨'}
                            </button>
                            <button class="layer-action-btn" data-index="${index}">×</button>
                        </div>
                    `;

                    item.querySelector('.layer-item-info').addEventListener('click', () => {
                        if (boundary.layer) {
                            map.fitBounds(boundary.layer.getBounds());
                        }
                    });

                    item.querySelector('.toggle').addEventListener('click', (e) => {
                        e.stopPropagation();
                        boundary.visible = !boundary.visible;
                        
                        if (boundary.visible) {
                            const showCheckbox = document.getElementById('show-boundaries-checkbox');
                            if (showCheckbox && showCheckbox.checked) {
                                boundaryLayers.addLayer(boundary.layer);
                            }
                        } else {
                            boundaryLayers.removeLayer(boundary.layer);
                        }
                        
                        updateLayersPanel();
                    });

                    item.querySelectorAll('.layer-action-btn')[1].addEventListener('click', (e) => {
                        e.stopPropagation();
                        boundaryLayers.removeLayer(boundary.layer);
                        allBoundaries.splice(index, 1);
                        updateLayersPanel();
                    });

                    boundaryList.appendChild(item);
                });

                // 更新事件列表
                const eventList = document.getElementById('event-layers-list');
                const eventCount = document.getElementById('event-count');
                eventList.innerHTML = '';
                eventCount.textContent = annotations.events.length;

                annotations.events.forEach((event, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    item.innerHTML = `
                        <div class="layer-item-info">
                            <div class="layer-item-name">${event.name}</div>
                            <div class="layer-item-date">${event.time} | ${event.location1} ${event.relation} ${event.location2}</div>
                        </div>
                        <div class="layer-item-actions">
                            <button class="layer-action-btn" data-index="${index}">×</button>
                        </div>
                    `;

                    item.querySelector('.layer-item-info').addEventListener('click', () => {
                        // 定位到事件区域
                        const bounds = L.latLngBounds([
                            L.latLng(event.loc1Coords.latitude, event.loc1Coords.longitude),
                            L.latLng(event.loc2Coords.latitude, event.loc2Coords.longitude)
                        ]);
                        map.fitBounds(bounds, { padding: [50, 50] });
                    });

                    item.querySelector('.layer-action-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteEvent(index);
                    });

                    eventList.appendChild(item);
                });

                // 更新标记列表
                const markerList = document.getElementById('marker-layers-list');
                const markerCount = document.getElementById('marker-count');
                markerList.innerHTML = '';
                const visibleMarkers = annotations.markers.filter(m => isSameDay(m.date, currentDate));
                markerCount.textContent = visibleMarkers.length;

                visibleMarkers.forEach((marker, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    item.innerHTML = `
                        <div class="layer-item-info">
                            <div class="layer-item-name">标记 #${index + 1}</div>
                            <div class="layer-item-date">${formatDate(marker.date)}</div>
                        </div>
                        <div class="layer-item-actions">
                            <button class="layer-action-btn">×</button>
                        </div>
                    `;

                    item.querySelector('.layer-item-info').addEventListener('click', () => {
                        map.setView(marker.latlng, 12);
                    });

                    item.querySelector('.layer-action-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (marker.layer) map.removeLayer(marker.layer);
                        annotations.markers = annotations.markers.filter(m => m !== marker);
                        updateLayersPanel();
                    });

                    markerList.appendChild(item);
                });

                // 更新线条列表
                const lineList = document.getElementById('line-layers-list');
                const lineCount = document.getElementById('line-count');
                lineList.innerHTML = '';
                const visibleLines = [...annotations.lines, ...annotations.arrows].filter(l => isSameDay(l.date, currentDate));
                lineCount.textContent = visibleLines.length;

                visibleLines.forEach((line, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    const typeName = line.type === 'arrow' ? '箭头' : line.type === 'chevron' ? '雪佛龙' : '线条';
                    item.innerHTML = `
                        <div class="layer-item-info">
                            <div class="layer-item-name">${typeName} #${index + 1}</div>
                            <div class="layer-item-date">${formatDate(line.date)}</div>
                        </div>
                        <div class="layer-item-actions">
                            <button class="layer-action-btn">×</button>
                        </div>
                    `;

                    item.querySelector('.layer-item-info').addEventListener('click', () => {
                        if (line.points && line.points.length > 0) {
                            map.setView(line.points[0], 12);
                        }
                    });

                    item.querySelector('.layer-action-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (line.layer) map.removeLayer(line.layer);
                        annotations.lines = annotations.lines.filter(l => l !== line);
                        annotations.arrows = annotations.arrows.filter(a => a !== line);
                        updateLayersPanel();
                    });

                    lineList.appendChild(item);
                });

                // 更新文本框列表
                const textList = document.getElementById('text-layers-list');
                const textCount = document.getElementById('text-count');
                textList.innerHTML = '';
                const visibleTexts = annotations.textBoxes.filter(t => isSameDay(t.date, currentDate));
                textCount.textContent = visibleTexts.length;

                visibleTexts.forEach((textBox, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    item.innerHTML = `
                        <div class="layer-item-info">
                            <div class="layer-item-name">文本 #${index + 1}</div>
                            <div class="layer-item-date">${formatDate(textBox.date)}</div>
                        </div>
                        <div class="layer-item-actions">
                            <button class="layer-action-btn">×</button>
                        </div>
                    `;

                    item.querySelector('.layer-item-info').addEventListener('click', () => {
                        map.setView(textBox.latlng, 12);
                    });

                    item.querySelector('.layer-action-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (textBox.cleanup) textBox.cleanup();
                        if (textBox.element) textBox.element.remove();
                        annotations.textBoxes = annotations.textBoxes.filter(t => t !== textBox);
                        updateLayersPanel();
                    });

                    textList.appendChild(item);
                });
            }

            function formatDate(date) {
                const d = new Date(date);
                return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
            }

            // 图层面板折叠功能
            document.getElementById('toggle-layers').addEventListener('click', function() {
                const content = document.querySelector('.layers-content');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    this.textContent = '▼';
                } else {
                    content.style.display = 'none';
                    this.textContent = '▶';
                }
            });

            function initDatabaseLoader() {
                const loadDbBtn = document.getElementById('load-db-btn');
                const dbFileInput = document.getElementById('db-file-input');

                loadDbBtn.addEventListener('click', () => {
                    dbFileInput.click();
                });

                dbFileInput.addEventListener('change', function(e) {
                    const files = e.target.files;
                    if (!files || files.length === 0) return;

                    showDbStatus(`正在加载 ${files.length} 个文件...`);
                    
                    let filesProcessed = 0;
                    let locationDbLoaded = false;
                    let geoJsonLoaded = 0;
                    
                    Array.from(files).forEach(file => {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            try {
                                const jsonData = JSON.parse(event.target.result);
                                
                                // 判断文件类型
                                if (isLocationDatabase(jsonData)) {
                                    // 这是地点数据库文件
                                    const rawDatabase = jsonData;
                                    
                                    // 查找并移除Taiwan
                                    const taiwanIndex = rawDatabase.findIndex(country => {
                                        const name = country.name.toLowerCase();
                                        return name === 'taiwan' || 
                                               name === 'taiwan, province of china' ||
                                               name.includes('taiwan');
                                    });
                                    
                                    let taiwanData = null;
                                    if (taiwanIndex !== -1) {
                                        taiwanData = rawDatabase[taiwanIndex];
                                        rawDatabase.splice(taiwanIndex, 1);
                                    }
                                    
                                    // 将台湾添加到中国的省份中
                                    const chinaIndex = rawDatabase.findIndex(country => {
                                        const name = country.name.toLowerCase();
                                        return name === 'china' || name === '中国';
                                    });
                                    
                                    if (chinaIndex !== -1 && taiwanData) {
                                        if (!rawDatabase[chinaIndex].states) {
                                            rawDatabase[chinaIndex].states = [];
                                        }
                                        
                                        const taiwanProvince = {
                                            id: taiwanData.id || 'taiwan_province',
                                            name: '台湾省',
                                            latitude: taiwanData.latitude || '23.5',
                                            longitude: taiwanData.longitude || '121',
                                            cities: taiwanData.states?.[0]?.cities || []
                                        };
                                        
                                        rawDatabase[chinaIndex].states.push(taiwanProvince);
                                    }
                                    
                                    geoDatabase = rawDatabase;
                                    databaseLoaded = true;
                                    locationDbLoaded = true;
                                    
                                    console.log(`地点数据库加载成功: ${file.name}`);
                                } else if (isGeoJSON(jsonData)) {
                                    // 这是GeoJSON边界文件
                                    const fileName = file.name.replace('.json', '').replace('.geojson', '');
                                    localGeoJSONFiles[fileName] = jsonData;
                                    geoJsonLoaded++;
                                    
                                    console.log(`GeoJSON边界文件加载成功: ${file.name}`);
                                } else {
                                    console.warn(`无法识别文件类型: ${file.name}`);
                                }
                                
                                filesProcessed++;
                                
                                // 所有文件处理完毕
                                if (filesProcessed === files.length) {
                                    let statusMsg = '';
                                    
                                    if (locationDbLoaded) {
                                        const totalCountries = geoDatabase.length;
                                        const totalStates = geoDatabase.reduce((sum, c) => sum + (c.states?.length || 0), 0);
                                        const totalCities = geoDatabase.reduce((sum, c) => 
                                            sum + (c.states?.reduce((s, st) => s + (st.cities?.length || 0), 0) || 0), 0
                                        );
                                        statusMsg = `✓ 地点库: ${totalCountries}国, ${totalStates}省, ${totalCities}市`;
                                    }
                                    
                                    if (geoJsonLoaded > 0) {
                                        statusMsg += ` | ${geoJsonLoaded}个边界文件`;
                                    }
                                    
                                    showDbStatus(statusMsg || '✓ 文件加载完成');
                                    
                                    if (databaseLoaded) {
                                        document.getElementById('country-select').disabled = false;
                                        document.getElementById('search-address-btn').disabled = false;
                                        populateCountries();
                                    }
                                }
                                
                            } catch (error) {
                                console.error(`解析文件失败 ${file.name}:`, error);
                                filesProcessed++;
                                
                                if (filesProcessed === files.length) {
                                    showDbStatus('部分文件加载失败', true);
                                }
                            }
                        };
                        
                        reader.onerror = function() {
                            console.error(`读取文件失败: ${file.name}`);
                            filesProcessed++;
                            
                            if (filesProcessed === files.length) {
                                showDbStatus('部分文件读取失败', true);
                            }
                        };
                        
                        reader.readAsText(file);
                    });
                });
            }
            
            // 判断是否是地点数据库
            function isLocationDatabase(data) {
                if (!Array.isArray(data)) return false;
                if (data.length === 0) return false;
                
                const sample = data[0];
                return sample.hasOwnProperty('name') && 
                       sample.hasOwnProperty('id') && 
                       (sample.hasOwnProperty('latitude') || sample.hasOwnProperty('states'));
            }
            
            // 判断是否是GeoJSON
            function isGeoJSON(data) {
                if (!data) return false;
                
                return data.type === 'FeatureCollection' || 
                       data.type === 'Feature' || 
                       data.type === 'GeometryCollection' ||
                       (data.type && ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 
                                      'Polygon', 'MultiPolygon'].includes(data.type));
            }

            function initLocationSearch() {
                const countrySelect = document.getElementById('country-select');
                const stateSelect = document.getElementById('state-select');
                const citySelect = document.getElementById('city-select');
                const goLocationBtn = document.getElementById('go-location-btn');
                const searchInput = document.getElementById('address-search-input');
                const searchBtn = document.getElementById('search-address-btn');
                const searchResults = document.getElementById('search-results');
                const resultsList = document.getElementById('results-list');

                if (!countrySelect || !stateSelect || !citySelect) {
                    console.error('下拉菜单元素未找到');
                    return;
                }

                let selectedCountry = null;
                let selectedState = null;
                let selectedCity = null;

                initDatabaseLoader();

                window.populateCountries = function() {
                    countrySelect.innerHTML = '<option value="">请选择国家</option>';
                    geoDatabase.sort((a, b) => a.name.localeCompare(b.name)).forEach(country => {
                        const option = document.createElement('option');
                        option.value = country.id;
                        option.textContent = country.name;
                        countrySelect.appendChild(option);
                    });
                };

                countrySelect.addEventListener('change', function() {
                    stateSelect.innerHTML = '<option value="">请选择州/省</option>';
                    citySelect.innerHTML = '<option value="">请先选择州/省</option>';
                    stateSelect.disabled = true;
                    citySelect.disabled = true;
                    goLocationBtn.disabled = true;
                    selectedState = null;
                    selectedCity = null;

                    if (!this.value) {
                        selectedCountry = null;
                        return;
                    }

                    selectedCountry = geoDatabase.find(c => c.id == this.value);
                    
                    goLocationBtn.disabled = false;
                    
                    if (selectedCountry && selectedCountry.states && selectedCountry.states.length > 0) {
                        selectedCountry.states.sort((a, b) => a.name.localeCompare(b.name)).forEach(state => {
                            const option = document.createElement('option');
                            option.value = state.id;
                            option.textContent = state.name;
                            stateSelect.appendChild(option);
                        });
                        stateSelect.disabled = false;
                    }
                });

                stateSelect.addEventListener('change', function() {
                    citySelect.innerHTML = '<option value="">请选择城市</option>';
                    citySelect.disabled = true;
                    selectedCity = null;

                    if (!this.value || !selectedCountry) {
                        selectedState = null;
                        goLocationBtn.disabled = false;
                        return;
                    }

                    selectedState = selectedCountry.states.find(s => s.id == this.value);
                    
                    goLocationBtn.disabled = false;
                    
                    if (selectedState && selectedState.cities && selectedState.cities.length > 0) {
                        selectedState.cities.sort((a, b) => a.name.localeCompare(b.name)).forEach(city => {
                            const option = document.createElement('option');
                            option.value = city.id;
                            option.textContent = city.name;
                            citySelect.appendChild(option);
                        });
                        citySelect.disabled = false;
                    }
                });

                citySelect.addEventListener('change', function() {
                    if (!this.value || !selectedState) {
                        selectedCity = null;
                        goLocationBtn.disabled = false;
                        return;
                    }

                    selectedCity = selectedState.cities.find(c => c.id == this.value);
                    goLocationBtn.disabled = false;
                });

                goLocationBtn.addEventListener('click', async function() {
                    let lat, lon, zoom, locationName, locationType;

                    if (selectedCity) {
                        lat = parseFloat(selectedCity.latitude);
                        lon = parseFloat(selectedCity.longitude);
                        zoom = 11;
                        locationName = selectedCity.name;
                        locationType = 'city';
                    } else if (selectedState) {
                        lat = parseFloat(selectedState.latitude);
                        lon = parseFloat(selectedState.longitude);
                        zoom = 7;
                        locationName = selectedState.name;
                        locationType = 'state';
                    } else if (selectedCountry) {
                        lat = parseFloat(selectedCountry.latitude);
                        lon = parseFloat(selectedCountry.longitude);
                        zoom = 5;
                        locationName = selectedCountry.name;
                        locationType = 'country';
                    }

                    if (!isNaN(lat) && !isNaN(lon)) {
                        map.setView([lat, lon], zoom);
                        showSearchStatus(`已定位到: ${locationName}`);
                        
                        // 检查是否是中国相关
                        const isChinaRelated = selectedCountry && 
                            (selectedCountry.name.toLowerCase().includes('china') || 
                             selectedCountry.name.includes('中国'));

                        if (isChinaRelated) {
                            // 中国相关，使用本地GeoJSON
                            await fetchBoundaryFromNominatim({
                                name: locationName,
                                displayName: locationName,
                                type: locationType,
                                country: 'China',
                                parentCountry: 'China'
                            });
                        } else {
                            // 其他国家使用API
                            await fetchBoundaryFromNominatim({
                                name: locationName,
                                displayName: locationName,
                                type: locationType
                            });
                        }
                        
                        setTimeout(() => {
                            document.getElementById('location-panel').style.display = 'none';
                        }, 1000);
                    } else {
                        showSearchStatus('该位置缺少坐标信息', true);
                    }
                });

                function searchAddress(query) {
                    if (!databaseLoaded) {
                        showSearchStatus('请先加载数据库', true);
                        return;
                    }

                    showSearchStatus('正在搜索...');
                    searchBtn.disabled = true;

                    setTimeout(() => {
                        const searchTerm = query.toLowerCase();
                        const results = [];

                        geoDatabase.forEach(country => {
                            const countryMatch = country.name.toLowerCase().includes(searchTerm);
                           
                            if (countryMatch) {
                                results.push({
                                    type: 'country',
                                    name: country.name,
                                    latitude: country.latitude,
                                    longitude: country.longitude,
                                    displayName: country.name,
                                    zoom: 5
                                });
                            }

                            country.states?.forEach(state => {
                                const stateMatch = state.name.toLowerCase().includes(searchTerm);
                                
                                if (stateMatch) {
                                    results.push({
                                        type: 'state',
                                        name: state.name,
                                        latitude: state.latitude,
                                        longitude: state.longitude,
                                        displayName: `${state.name} - ${country.name}`,
                                        zoom: 7
                                    });
                                }

                                state.cities?.forEach(city => {
                                    if (city.name.toLowerCase().includes(searchTerm)) {
                                        results.push({
                                            type: 'city',
                                            name: city.name,
                                            latitude: city.latitude,
                                            longitude: city.longitude,
                                            displayName: `${city.name} - ${state.name}, ${country.name}`,
                                            zoom: 11
                                        });
                                    }
                                });
                            });
                        });

                        if (results.length === 0) {
                            showSearchStatus('未找到匹配的地址', true);
                            searchResults.style.display = 'none';
                            searchBtn.disabled = false;
                            return;
                        }

                        const sortedResults = results.sort((a, b) => {
                            const order = { city: 1, state: 2, country: 3 };
                            return order[a.type] - order[b.type];
                        }).slice(0, 20);

                        displayResults(sortedResults);
                        showSearchStatus(`找到 ${sortedResults.length} 个结果`);
                        searchBtn.disabled = false;
                    }, 100);
                }

                function displayResults(results) {
                    resultsList.innerHTML = '';
                    
                    results.forEach((location) => {
                        const resultItem = document.createElement('div');
                        resultItem.className = 'result-item';
                        
                        const typeText = location.type === 'country' ? '国家' : 
                                        location.type === 'state' ? '州/省' : '城市';
                        
                        resultItem.innerHTML = `
                            <div style="font-weight: bold; margin-bottom: 3px;">${location.displayName}</div>
                            <div style="font-size: 11px; color: #666;">${typeText}</div>
                        `;
                        
                        resultItem.addEventListener('click', async () => {
                            const lat = parseFloat(location.latitude);
                            const lon = parseFloat(location.longitude);
                            
                            if (isNaN(lat) || isNaN(lon)) {
                                showSearchStatus('该位置缺少坐标信息', true);
                                return;
                            }
                            
                            map.setView([lat, lon], location.zoom);
                            
                            showSearchStatus(`已定位到: ${location.displayName}`);
                            searchResults.style.display = 'none';
                            
                            // 检查是否是中国相关
                            const isChinaRelated = location.displayName.includes('中国') || 
                                                  location.displayName.includes('China');

                            if (isChinaRelated) {
                                // 中国相关，使用本地GeoJSON
                                await fetchBoundaryFromNominatim({
                                    name: location.name,
                                    displayName: location.name,
                                    type: location.type,
                                    country: 'China',
                                    parentCountry: 'China'
                                });
                            } else {
                                // 其他国家使用API
                                await fetchBoundaryFromNominatim({
                                    name: location.displayName,
                                    displayName: location.displayName,
                                    type: location.type
                                });
                            }
                            
                            setTimeout(() => {
                                document.getElementById('location-panel').style.display = 'none';
                            }, 1000);
                        });
                        
                        resultsList.appendChild(resultItem);
                    });
                    
                    searchResults.style.display = 'block';
                }

                searchBtn.addEventListener('click', () => {
                    const query = searchInput.value.trim();
                    if (!query) {
                        showSearchStatus('请输入搜索内容', true);
                        return;
                    }
                    searchAddress(query);
                });

                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        searchBtn.click();
                    }
                });

                searchInput.addEventListener('input', () => {
                    if (searchInput.value.trim() === '') {
                        searchResults.style.display = 'none';
                        showSearchStatus('');
                    }
                });
            }

            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '255, 255, 255';
            }
            
            function getSplinePoints(points, tension = 0.5, resolution = 16) {
                if (points.length < 2) return points;
                let pts = points;
                let splinePoints = [pts[0]]; 
                for (let i = 0; i < pts.length - 1; i++) {
                    const p0 = (i === 0) ? pts[i] : pts[i - 1];
                    const p1 = pts[i];
                    const p2 = pts[i + 1];
                    const p3 = (i === pts.length - 2) ? pts[i + 1] : pts[i + 2];
                    for (let t = 1; t <= resolution; t++) { 
                        const step = t / resolution;
                        const t2 = step * step;
                        const t3 = t2 * step;
                        const h1 = 2 * t3 - 3 * t2 + 1;
                        const h2 = -2 * t3 + 3 * t2;
                        const h3 = t3 - 2 * t2 + step;
                        const h4 = t3 - t2;
                        const m1_lat = (p2.lat - p0.lat) * tension;
                        const m2_lat = (p3.lat - p1.lat) * tension;
                        const m1_lng = (p2.lng - p0.lng) * tension;
                        const m2_lng = (p3.lng - p1.lng) * tension;
                        const lat = h1 * p1.lat + h2 * p2.lat + h3 * m1_lat + h4 * m2_lat;
                        const lng = h1 * p1.lng + h2 * p2.lng + h3 * m1_lng + h4 * m2_lng;
                        splinePoints.push(L.latLng(lat, lng));
                    }
                }
                return splinePoints;
            }
            
            const themeSettings = {
                buttonColor: '#666666', 
                fillColor: '#ffffff',
                fillOpacity: 0.5
            };
            
            function applyTheme() {
                const buttonRgb = hexToRgb(themeSettings.buttonColor);
                document.querySelectorAll('.btn, .calendar-header button').forEach(el => {
                    el.style.background = themeSettings.buttonColor;
                });
                document.querySelectorAll('.tool-icon.active, .file-icon.active').forEach(el => {
                    el.style.background = `rgba(${buttonRgb}, 0.5)`;
                });
                document.querySelectorAll('#tool-panel, #date-selector, #location-panel, #file-controls, #zoom-control').forEach(el => {
                    el.style.background = `rgba(${hexToRgb(themeSettings.fillColor)}, ${themeSettings.fillOpacity})`;
                });
                const dateDisplay = document.getElementById('date-display');
                if (dateDisplay) {
                    dateDisplay.style.color = themeSettings.buttonColor; 
                }
                const track = document.getElementById('zoom-slider-track');
                const thumb = document.getElementById('zoom-slider-thumb');
                if (track) track.style.background = themeSettings.buttonColor;
                if (thumb) thumb.style.borderColor = themeSettings.buttonColor;
                document.querySelectorAll('.zoom-level-mark.current').forEach(mark => {
                    mark.style.color = themeSettings.buttonColor;
                });
            }

            function initYearSelect() {
                yearSelect.innerHTML = '';
                for (let y = -2500; y <= 2100; y++) {
                    const option = document.createElement('option');
                    option.value = y;
                    option.textContent = y > 0 ? y + '年' : '公元前' + Math.abs(y) + '年';
                    yearSelect.appendChild(option);
                }
            }

            function renderCalendar() {
                const year = calendarDate.getFullYear();
                const month = calendarDate.getMonth();
                yearSelect.value = year;
                monthSelect.value = month;
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const prevLastDay = new Date(year, month, 0);
                const firstDayWeek = firstDay.getDay();
                const lastDate = lastDay.getDate();
                const prevLastDate = prevLastDay.getDate();
                let html = '';
                for (let i = firstDayWeek - 1; i >= 0; i--) {
                    const day = prevLastDate - i;
                    html += `<div class="calendar-day other-month" data-date="${year}-${month}-${day}">${day}</div>`;
                }
                for (let day = 1; day <= lastDate; day++) {
                    const dateStr = `${year}-${month + 1}-${day}`;
                    const isSelected = currentDate.getFullYear() === year && 
                                      currentDate.getMonth() === month && 
                                      currentDate.getDate() === day;
                    const isToday = new Date().getFullYear() === year && 
                                   new Date().getMonth() === month && 
                                   new Date().getDate() === day;
                    let classes = 'calendar-day';
                    if (isSelected) classes += ' selected';
                    if (isToday) classes += ' today';
                    html += `<div class="${classes}" data-date="${dateStr}">${day}</div>`;
                }
                const remainingDays = 42 - (firstDayWeek + lastDate);
                for (let day = 1; day <= remainingDays; day++) {
                    html += `<div class="calendar-day other-month" data-date="${year}-${month + 2}-${day}"></div>`;
                }
                calendarDays.innerHTML = html;
                calendarDays.querySelectorAll('.calendar-day:not(.other-month)').forEach(dayEl => {
                    dayEl.addEventListener('click', function() {
                        const [y, m, d] = this.dataset.date.split('-').map(Number);
                        currentDate = new Date(y, m - 1, d);
                        updateDateDisplay();
                        renderCalendar();
                        calendarContainer.classList.remove('show');
                    });
                });
            }

            dateDisplayEl.addEventListener('click', function(e) {
                e.stopPropagation();
                calendarContainer.classList.toggle('show');
                if (calendarContainer.classList.contains('show')) {
                    calendarDate = new Date(currentDate);
                    renderCalendar();
                }
            });

            document.addEventListener('click', function(e) {
                if (!calendarContainer.contains(e.target) && e.target !== dateDisplayEl) {
                    calendarContainer.classList.remove('show');
                }
            });

            prevMonthBtn.addEventListener('click', function() {
                calendarDate.setMonth(calendarDate.getMonth() - 1);
                renderCalendar();
            });

            nextMonthBtn.addEventListener('click', function() {
                calendarDate.setMonth(calendarDate.getMonth() + 1);
                renderCalendar();
            });

            yearSelect.addEventListener('change', function() {
                calendarDate.setFullYear(parseInt(this.value));
                renderCalendar();
            });

            monthSelect.addEventListener('change', function() {
                calendarDate.setMonth(parseInt(this.value));
                renderCalendar();
            });

            function updateDateDisplay() {
                const y = currentDate.getFullYear();
                const m = String(currentDate.getMonth() + 1).padStart(2, '0');
                const d = String(currentDate.getDate()).padStart(2, '0');
                dateDisplayEl.textContent = `当前日期: ${y}-${m}-${d}`;
                clearDrawingState();
                updateVisibleAnnotations();
            }

            function showHint(text) {
                const hint = document.getElementById('hint');
                if (text) {
                    hint.textContent = text;
                    hint.style.display = 'block';
                } else {
                    hint.style.display = 'none';
                }
            }

            function updateMapCursor() {
                const mapEl = document.getElementById('map');
                mapEl.className = '';
                if (currentTool === 'pan') {
                    mapEl.classList.add('pan-mode');
                    map.doubleClickZoom.enable();
                } else if (currentTool === 'eraser') {
                    mapEl.classList.add('eraser-mode');
                    map.doubleClickZoom.disable();
                } else {
                    map.doubleClickZoom.disable();
                }
            }

            function isSameDay(date1, date2) {
                if (!date1 || !date2) return false;
                return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
            }

            function updateVisibleAnnotations() {
                const currentZoom = map.getZoom();
                [...annotations.markers, ...annotations.lines, ...annotations.arrows].forEach(a => {
                    if (a.layer) map.removeLayer(a.layer);
                });
                annotations.textBoxes.forEach(t => {
                    if (t.element) t.element.style.display = 'none';
                });
                const allAnnotations = [
                    ...annotations.markers,
                    ...annotations.lines,
                    ...annotations.arrows,
                    ...annotations.textBoxes
                ];
                allAnnotations.forEach(a => {
                    const isSameDate = isSameDay(a.date, currentDate);
                    const createdZoom = a.zoomLevel || 18;
                    const zoomDiff = currentZoom - createdZoom;
                    
                    let opacity = 1.0;
                    let shouldShow = true;
                    
                    if (zoomDiff <= 0) {
                        opacity = 1.0;
                    } else if (zoomDiff >= 4) {
                        shouldShow = false;
                    } else {
                        opacity = 1.0 - (zoomDiff * 0.25);
                    }
                    
                    const isVisible = isSameDate && shouldShow;
                    
                    if (isVisible) {
                        if (a.layer) {
                            if (!map.hasLayer(a.layer)) map.addLayer(a.layer);
                            
                            if (a.type === 'marker') {
                                const icon = a.layer.getElement();
                                if (icon) {
                                    icon.style.opacity = opacity;
                                }
                            } else if (a.type === 'line') {
                                a.layer.setStyle({ opacity: opacity * (a.options.opacity || 1) });
                            } else if (a.type === 'arrow' || a.type === 'chevron') {
                                a.layer.eachLayer(subLayer => {
                                    if (subLayer.setStyle) {
                                        subLayer.setStyle({ opacity: opacity * (a.options.opacity || 1), fillOpacity: opacity * (a.options.opacity || 1) });
                                    }
                                    if (subLayer.getElement) {
                                        const elem = subLayer.getElement();
                                        if (elem) elem.style.opacity = opacity;
                                    }
                                });
                            }
                        } else if (a.element) {
                            a.element.style.display = 'block';
                            a.element.style.opacity = opacity * (a.options.opacity || 1);
                        }
                    }
                });
                
                updateLayersPanel();
            }

            function clearDrawingState() {
                if (drawingState.tempMarker) {
                    map.removeLayer(drawingState.tempMarker);
                    drawingState.tempMarker = null;
                }
                if (drawingState.previewLayer) {
                    map.removeLayer(drawingState.previewLayer);
                    drawingState.previewLayer = null;
                }
                drawingState.dashedSegments.forEach(seg => map.removeLayer(seg));
                drawingState.dashedSegments = [];
                drawingState.isDrawing = false;
                drawingState.startPoint = null;
                drawingState.points = [];
            }

            function updateToolOptions() {
                document.querySelectorAll('.tool-options-popup').forEach(p => p.remove());
                if (!['annotate', 'text'].includes(currentTool)) return;
                const activeIcon = document.querySelector(`[data-tool="${currentTool}"]`);
                if (!activeIcon) return;
                let html = '';
                let helpText = '';
                if (currentTool === 'annotate') {
                    const opts = toolOptions.annotate;
                    html = `<div class="help-icon" data-hint="${helpText}">?</div>
                    <div class="option-group" style="grid-column: 1 / -1;"><label>标记样式 (单击):</label><select id="annotate-marker-type">
                        <option value="pin">大头针</option>
                        <option value="pushpin">图钉</option>
                        <option value="dot">圆点</option>
                        <option value="none">无标记</option> 
                    </select></div>
                    <div class="option-group" style="grid-column: 1 / -1;"><label>线条样式:</label><select id="annotate-line-style">
                        <option value="solid">实线</option>
                        <option value="dashed">虚线</option>
                        <option value="arrow">箭头</option>
                        <option value="chevron">雪佛龙箭头</option>
                    </select></div>
                    <div class="option-group" style="grid-column: 1 / -1;"><label>线条类型:</label><select id="annotate-line-type">
                        <option value="straight">直线</option>
                        <option value="bezier">贝塞尔曲线</option>
                    </select></div>
                    <div class="option-group"><label>颜色:</label><div class="color-picker"><input type="color" id="annotate-color" value="${opts.color}"></div></div>
                    <div class="option-group"><label>粗细:</label><input type="number" id="annotate-weight" value="${opts.weight}" min="1" max="10"></div>
                    <div class="option-group" style="grid-column: 1 / -1;"><label>不透明度: <span id="line-opacity-display">${Math.round(opts.opacity * 100)}%</span></label><input type="range" id="annotate-opacity" value="${opts.opacity}" min="0" max="1" step="0.1"></div>
                    <div class="option-group" style="grid-column: 1 / -1; display: ${opts.lineStyle === 'arrow' ? 'block' : 'none'};" id="arrow-text-group"><label>箭头文字:</label><input type="text" id="annotate-arrow-text" value="${opts.arrowText}" placeholder="说明 (可选)"></div>`;
                } else if (currentTool === 'text') {
                    const opts = toolOptions.text;
                    html = `<div class="help-icon" data-hint="${helpText}">?</div>
                    <div class="option-group"><label>背景:</label><div class="color-picker"><input type="color" id="text-bg-color" value="${opts.bgColor}"></div></div>
                    <div class="option-group"><label>文字:</label><div class="color-picker"><input type="color" id="text-color" value="${opts.textColor}"></div></div>
                    <div class="option-group" style="grid-column: 1 / -1;"><label>透明度: <span id="opacity-display">${Math.round(opts.opacity * 100)}%</span></label><input type="range" id="text-opacity" value="${opts.opacity}" min="0" max="1" step="0.1"></div>`;
                }
                const popup = document.createElement('div');
                popup.className = 'tool-options-popup show';
                popup.innerHTML = html;
                popup.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
                activeIcon.appendChild(popup);
                attachOptionListeners();
            }

            function attachOptionListeners() {
                const markerTypeEl = document.getElementById('annotate-marker-type');
                const lineStyleEl = document.getElementById('annotate-line-style');
                const lineTypeEl = document.getElementById('annotate-line-type');
                const colorEl = document.getElementById('annotate-color');
                const weightEl = document.getElementById('annotate-weight');
                const opacityEl = document.getElementById('annotate-opacity');
                const arrowTextEl = document.getElementById('annotate-arrow-text');
                const arrowTextGroup = document.getElementById('arrow-text-group');
                if (markerTypeEl) markerTypeEl.value = toolOptions.annotate.markerType;
                if (lineStyleEl) lineStyleEl.value = toolOptions.annotate.lineStyle;
                if (lineTypeEl) lineTypeEl.value = toolOptions.annotate.lineType;
                if (markerTypeEl) markerTypeEl.onchange = e => toolOptions.annotate.markerType = e.target.value;
                if (lineStyleEl) lineStyleEl.onchange = e => {
                    toolOptions.annotate.lineStyle = e.target.value;
                    if (arrowTextGroup) {
                        arrowTextGroup.style.display = e.target.value === 'arrow' ? 'block' : 'none';
                    }
                };
                if (lineTypeEl) lineTypeEl.onchange = e => toolOptions.annotate.lineType = e.target.value;
                if (colorEl) colorEl.onchange = e => toolOptions.annotate.color = e.target.value;
                if (weightEl) weightEl.onchange = e => toolOptions.annotate.weight = parseInt(e.target.value);
                if (opacityEl) opacityEl.oninput = e => {
                    toolOptions.annotate.opacity = parseFloat(e.target.value);
                    const display = document.getElementById('line-opacity-display');
                    if (display) display.textContent = Math.round(toolOptions.annotate.opacity * 100) + '%';
                };
                if (arrowTextEl) arrowTextEl.oninput = e => toolOptions.annotate.arrowText = e.target.value;
                const textBgColor = document.getElementById('text-bg-color');
                const textColor = document.getElementById('text-color');
                const textOpacity = document.getElementById('text-opacity');
                if (textBgColor) textBgColor.onchange = e => toolOptions.text.bgColor = e.target.value;
                if (textColor) textColor.onchange = e => toolOptions.text.textColor = e.target.value;
                if (textOpacity) textOpacity.oninput = e => {
                    toolOptions.text.opacity = parseFloat(e.target.value);
                    document.getElementById('opacity-display').textContent = Math.round(toolOptions.text.opacity * 100) + '%';
                };
            }

            document.querySelectorAll('.tool-icon').forEach(icon => {
                icon.onclick = function() {
                    const tool = this.dataset.tool;
                    if (!tool) return;
                    if (tool === 'clear') {
                        clearDrawingState();
                        if(confirm('确定要清空所有标注吗?')) {
                            annotations.markers.forEach(m => m.layer && map.removeLayer(m.layer));
                            annotations.lines.forEach(l => l.layer && map.removeLayer(l.layer));
                            annotations.arrows.forEach(a => a.layer && map.removeLayer(a.layer));
                            annotations.textBoxes.forEach(t => {
                                if (t.cleanup) t.cleanup();
                                if (t.element) t.element.remove();
                            });
                            annotations.markers = [];
                            annotations.lines = [];
                            annotations.arrows = [];
                            annotations.textBoxes = [];
                            updateLayersPanel();
                        }
                        return;
                    }
                    if (tool === 'location') {
                        const panel = document.getElementById('location-panel');
                        if (panel.style.display === 'block') {
                            panel.style.display = 'none';
                        } else {
                            panel.style.display = 'block';
                        }
                        document.querySelectorAll('.tool-options-popup').forEach(p => p.remove());
                        return;
                    }
                    if (currentTool === tool && tool !== 'pan') {
                        document.querySelectorAll('.tool-icon').forEach(i => {
                            i.classList.remove('active');
                            i.style.background = '';
                        });
                        const panIcon = document.querySelector('[data-tool="pan"]');
                        panIcon.classList.add('active');
                        panIcon.style.background = `rgba(${hexToRgb(themeSettings.buttonColor)}, 0.5)`;
                        currentTool = 'pan';
                        clearDrawingState();
                        document.querySelectorAll('.tool-options-popup').forEach(p => p.remove());
                        updateMapCursor();
                        map.dragging.enable();
                        return;
                    }
                    document.querySelectorAll('.tool-icon').forEach(i => {
                        i.classList.remove('active');
                        i.style.background = '';
                    });
                    this.classList.add('active');
                    currentTool = tool;
                    clearDrawingState();
                    updateToolOptions();
                    updateMapCursor();
                    if (tool === 'pan') {
                        map.dragging.enable();
                        showHint('');
                    } else if (tool === 'eraser') {
                        map.dragging.disable();
                    } else {
                        map.dragging.disable();
                    }
                };
            });

            function getMarkerSvg(type, color) {
                if (type === 'pin') {
                    return `<svg width="24" height="24" viewBox="0 0 24 24" fill="${color}" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0118 0z"/><circle cx="12" cy="10" r="3"/>
                    </svg>`;
                } else if (type === 'pushpin') {
                    return `<svg width="24" height="24" viewBox="0 0 24 24" fill="${color}" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 21v-4m-6-6h12M17 10l-5-5-5 5-2-2 7-7 7 7-2 2z"/>
                    </svg>`;
                } else if (type === 'dot') {
                    return '';
                }
                return '';
            }

            function createMarker(latlng, options) {
                const type = options.markerType;
                const color = options.color;
                if (type === 'dot') {
                    const icon = L.divIcon({
                        className: 'custom-marker dot-icon',
                        html: '',
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    });
                    const marker = L.marker(latlng, { icon: icon });
                    marker.getElement = () => marker._icon;
                    marker.on('add', function() {
                         this._icon.style.background = color;
                         this._icon.style.borderColor = 'white';
                    });
                    return marker;
                }
                const icon = L.divIcon({
                    className: `custom-marker ${type}-icon`,
                    html: getMarkerSvg(type, color),
                    iconSize: [24, 24],
                    iconAnchor: [12, 24]
                });
                return L.marker(latlng, { icon: icon });
            }

            function createLine(points, options) {
                const dashArray = options.lineStyle === 'dashed' ? '10, 10' : null;
                const weight = options.weight;
                const color = options.color;
                const opacity = options.opacity || 1;
                let pointsToDraw = points;
                if (options.lineType === 'bezier') {
                    pointsToDraw = getSplinePoints(points, 0.5, 32); 
                }
                const layer = L.polyline(pointsToDraw, {
                    color: color, weight: weight, dashArray: dashArray, opacity: opacity
                });
                return layer;
            }

            function createArrow(points, options) {
                const color = options.color;
                const weight = options.weight;
                const text = options.arrowText;
                const opacity = options.opacity || 1;
                const lineLayer = createLine(points, {
                    lineStyle: 'solid',
                    lineType: options.lineType, 
                    weight: weight, 
                    color: color,
                    opacity: opacity
                });
                const lastPoint = points[points.length - 1];
                const prevPoint = points[points.length - 2] || points[0];
                const angleRad = Math.atan2(lastPoint.lat - prevPoint.lat, lastPoint.lng - prevPoint.lng);
                const angleDeg = angleRad * (180 / Math.PI);
                const arrowSize = weight * 3;
                const arrowIcon = L.divIcon({
                    className: 'arrow-icon',
                    html: `<div style="color: ${color}; opacity: ${opacity}; font-size: ${arrowSize}px; transform: rotate(${-angleDeg - 90}deg); line-height: 1; display: flex; align-items: center; justify-content: center;">▼</div><span style="position:absolute; bottom:100%; left:50%; transform:translate(-50%, -10px); color:${color}; opacity: ${opacity}; white-space:nowrap;">${text}</span>`,
                    iconSize: [arrowSize, arrowSize],
                    iconAnchor: [arrowSize / 2, arrowSize / 2]
                });
                const arrowMarker = L.marker(lastPoint, { icon: arrowIcon });
                const group = L.layerGroup([lineLayer, arrowMarker]);
                group.removeArrow = () => { map.removeLayer(lineLayer); map.removeLayer(arrowMarker); };
                return { layer: group, type: 'arrow', date: new Date(currentDate), options: options, points: points };
            }

            function createChevron(points, options, map) {
                const color = options.color;
                const weight = options.weight;
                const opacity = options.opacity || 1;
                let pathPoints = points;
                if (options.lineType === 'bezier') {
                    pathPoints = getSplinePoints(points, 0.5, 32);
                }
                let totalDistance = 0;
                const segments = [];
                for (let i = 0; i < pathPoints.length - 1; i++) {
                    const p1 = pathPoints[i];
                    const p2 = pathPoints[i + 1];
                    const dx = p2.lng - p1.lng;
                    const dy = p2.lat - p1.lat;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    segments.push({ p1, p2, distance: dist, angle: Math.atan2(dy, dx) });
                    totalDistance += dist;
                }
                
                // 根据缩放级别动态调整雪佛龙大小
                // 在Leaflet中，256像素 = 360度 / 2^zoom
                // 所以 1像素 = 360 / (256 * 2^zoom) 度
                const currentZoom = map.getZoom();
                const pixelSize = 360 / (256 * Math.pow(2, currentZoom)); // 1像素对应的度数
                
                const desiredPixelWidth = 15; // 期望的像素宽度
                const desiredPixelHeight = weight * 1.5; // 期望的像素高度
                
                const chevronWidth = desiredPixelWidth * pixelSize;
                const chevronHeight = desiredPixelHeight * pixelSize;
                const spacing = chevronWidth * 0.5; 
                const chevronCount = Math.floor(totalDistance / (chevronWidth + spacing)); 
                const chevrons = [];
                for (let i = 0; i < chevronCount; i++) {
                    const targetDist = (i + 0.5) * (totalDistance / chevronCount);
                    let accumulatedDist = 0;
                    let segment = null;
                    let localDist = 0;
                    for (const seg of segments) {
                        if (accumulatedDist + seg.distance >= targetDist) {
                            segment = seg;
                            localDist = targetDist - accumulatedDist;
                            break;
                        }
                        accumulatedDist += seg.distance;
                    }
                    if (!segment) continue;
                    const ratio = localDist / segment.distance;
                    const centerLat = segment.p1.lat + (segment.p2.lat - segment.p1.lat) * ratio;
                    const centerLng = segment.p1.lng + (segment.p2.lng - segment.p1.lng) * ratio;
                    const angle = segment.angle;
                    const hw = chevronWidth / 2;
                    const hh = chevronHeight / 2;
                    const points = [
                        L.latLng(
                            centerLat - hw * Math.sin(angle) - hh * Math.cos(angle),
                            centerLng - hw * Math.cos(angle) + hh * Math.sin(angle)
                        ),
                        L.latLng(
                            centerLat + hw * 0.40 * Math.sin(angle) - hh * 0.90 * Math.cos(angle),
                            centerLng + hw * 0.40 * Math.cos(angle) + hh * 0.90 * Math.sin(angle)
                        ),
                        L.latLng(
                            centerLat + hw * Math.sin(angle),
                            centerLng + hw * Math.cos(angle)
                        ),
                        L.latLng(
                            centerLat + hw * 0.40 * Math.sin(angle) + hh * 0.90 * Math.cos(angle),
                            centerLng + hw * 0.40 * Math.cos(angle) - hh * 0.90 * Math.sin(angle)
                        ),
                        L.latLng(
                            centerLat - hw * Math.sin(angle) + hh * Math.cos(angle),
                            centerLng - hw * Math.cos(angle) - hh * Math.sin(angle)
                        ),
                        L.latLng(
                            centerLat - hw * 0.40 * Math.sin(angle),
                            centerLng - hw * 0.40 * Math.cos(angle)
                        )
                    ];
                    chevrons.push(points);
                }
                const chevronLayers = chevrons.map(points => 
                    L.polygon(points, {
                        color: color,
                        fillColor: color,
                        fillOpacity: opacity,
                        weight: 0,
                        opacity: opacity
                    })
                );
                const group = L.layerGroup(chevronLayers);
                
                // 存储创建时的缩放级别
                group._chevronZoom = currentZoom;
                
                return { layer: group, type: 'chevron', date: new Date(currentDate), options: options, points: points };
            }

            function createTextBox(latlng, options) {
                const element = document.createElement('div');
                element.className = 'text-box';
                element.style.background = options.bgColor;
                element.style.opacity = options.opacity;
                element.style.borderColor = themeSettings.buttonColor;
                element.style.left = map.latLngToContainerPoint(latlng).x + 'px';
                element.style.top = map.latLngToContainerPoint(latlng).y + 'px';
                element.style.zIndex = 500 + annotations.textBoxes.length;
                const textarea = document.createElement('textarea');
                textarea.style.color = options.textColor;
                textarea.style.height = '100px'; 
                textarea.placeholder = '在此输入文本...';
                element.appendChild(textarea);
                const closeBtn = document.createElement('span');
                closeBtn.className = 'text-box-close';
                closeBtn.innerHTML = '✕';
                element.appendChild(closeBtn);
                map.getContainer().appendChild(element);
                const draggable = new L.Draggable(element);
                draggable.enable();
                let currentLatLng = latlng;
                function updateLatLng() {
                    const newMapPoint = L.point(element.style.left.slice(0, -2), element.style.top.slice(0, -2));
                    currentLatLng = map.containerPointToLatLng(newMapPoint);
                }
                draggable.on('drag', updateLatLng);
                closeBtn.onclick = function() {
                    element.remove();
                    annotations.textBoxes = annotations.textBoxes.filter(t => t.element !== element);
                };
                function cleanup() {
                    map.removeEventListener('move', onMapMove);
                }
                function onMapMove() {
                    const newPoint = map.latLngToContainerPoint(currentLatLng);
                    element.style.left = newPoint.x + 'px';
                    element.style.top = newPoint.y + 'px';
                }
                map.on('move', onMapMove);
                return { 
                    element: element, 
                    type: 'textbox', 
                    date: new Date(currentDate), 
                    options: options, 
                    latlng: latlng,
                    content: textarea.value,
                    cleanup: cleanup
                };
            }

            map.on('click', function(e) {
                if (currentTool === 'annotate') {
                    if (drawingState.isDrawing) {
                        return; 
                    } 
                    const options = toolOptions.annotate;
                    if (options.markerType !== 'none') {
                        const markerLayer = createMarker(e.latlng, options);
                        annotations.markers.push({ 
                            layer: markerLayer, 
                            type: 'marker', 
                            date: new Date(currentDate), 
                            options: options, 
                            latlng: e.latlng,
                            zoomLevel: map.getZoom()
                        });
                        markerLayer.addTo(map);
                        updateLayersPanel();
                    }
                } else if (currentTool === 'text') {
                    const textBox = createTextBox(e.latlng, toolOptions.text);
                    textBox.zoomLevel = map.getZoom();
                    annotations.textBoxes.push(textBox);
                    updateLayersPanel();
                }
            });

            map.on('dblclick', function(e) {
                if (currentTool !== 'annotate') return;
                if (!drawingState.isDrawing) {
                    drawingState.isDrawing = true;
                    drawingState.points = [e.latlng];
                    drawingState.startPoint = e.latlng;
                    map.dragging.disable();
                } else {
                    drawingState.points.push(e.latlng);
                    if (drawingState.points.length >= 2) {
                        const lastPoint = drawingState.points[drawingState.points.length - 2];
                        const finalPoint = e.latlng;
                        const finalDashedSegment = L.polyline([lastPoint, finalPoint], {
                            color: toolOptions.annotate.color,
                            weight: toolOptions.annotate.weight,
                            opacity: 0.6,
                            dashArray: '10, 10'
                        }).addTo(map);
                        drawingState.dashedSegments.push(finalDashedSegment);
                    }
                    if (drawingState.points.length >= 2) {
                        const options = toolOptions.annotate;
                        let annotation;
                        if (drawingState.previewLayer) map.removeLayer(drawingState.previewLayer);
                        drawingState.dashedSegments.forEach(seg => map.removeLayer(seg));
                        if (options.lineStyle === 'arrow') {
                            annotation = createArrow(drawingState.points, options);
                            annotation.zoomLevel = map.getZoom();
                            annotations.arrows.push(annotation);
                            annotation.layer.addTo(map);
                        } else if (options.lineStyle === 'chevron') {
                            annotation = createChevron(drawingState.points, options, map);
                            annotation.zoomLevel = map.getZoom();
                            annotations.arrows.push(annotation);
                            annotation.layer.addTo(map);
                        } else {
                            const lineLayer = createLine(drawingState.points, options);
                            annotation = { 
                                layer: lineLayer, 
                                type: 'line', 
                                date: new Date(currentDate), 
                                options: options, 
                                points: drawingState.points,
                                zoomLevel: map.getZoom()
                            };
                            annotations.lines.push(annotation);
                            lineLayer.addTo(map);
                        }
                        
                        updateLayersPanel();
                    }
                    clearDrawingState();
                    map.dragging.disable();
                }
            });

            map.on('contextmenu', function(e) {
                if (currentTool === 'annotate' && drawingState.isDrawing) {
                    const lastPoint = drawingState.points[drawingState.points.length - 1];
                    const newPoint = e.latlng;
                    const dashedSegment = L.polyline([lastPoint, newPoint], {
                        color: toolOptions.annotate.color,
                        weight: toolOptions.annotate.weight,
                        opacity: 0.6,
                        dashArray: '10, 10'
                    }).addTo(map);
                    drawingState.dashedSegments.push(dashedSegment);
                    drawingState.points.push(newPoint);
                    map.fire('mousemove', { latlng: e.latlng });
                }
            });

            map.on('mousemove', function(e) {
                if (currentTool === 'eraser' && eraserState.isErasing) {
                } else if (drawingState.isDrawing && drawingState.points.length > 0) {
                    if (drawingState.previewLayer) map.removeLayer(drawingState.previewLayer);
                    const lastPoint = drawingState.points[drawingState.points.length - 1];
                    const options = toolOptions.annotate;
                    let previewPoints = [lastPoint, e.latlng];
                    if (options.lineType === 'bezier') {
                        const allPoints = [...drawingState.points, e.latlng];
                        previewPoints = getSplinePoints(allPoints, 0.5, 16); 
                    } else {
                        previewPoints = [lastPoint, e.latlng];
                    }
                    drawingState.previewLayer = L.polyline(previewPoints, {
                        color: options.color, weight: options.weight, opacity: 0.5, dashArray: '10, 10'
                    }).addTo(map);
                }
            });

            document.getElementById('save-btn').addEventListener('click', function() {
                const data = {
                    date: currentDate.toISOString().split('T')[0],
                    annotations: {
                        markers: annotations.markers.map(a => ({
                            type: a.type, date: a.date.toISOString(), options: a.options, latlng: a.latlng, zoomLevel: a.zoomLevel
                        })),
                        lines: annotations.lines.map(a => ({
                            type: a.type, date: a.date.toISOString(), options: a.options, points: a.points, zoomLevel: a.zoomLevel
                        })),
                        arrows: annotations.arrows.map(a => ({
                            type: a.type, date: a.date.toISOString(), options: a.options, points: a.points, zoomLevel: a.zoomLevel
                        })),
                        textBoxes: annotations.textBoxes.map(a => ({
                            type: a.type, date: a.date.toISOString(), options: a.options, latlng: a.latlng, content: a.element.querySelector('textarea').value, zoomLevel: a.zoomLevel
                        }))
                    },
                    boundaries: allBoundaries.map(b => ({
                        name: b.name,
                        type: b.type,
                        visible: b.visible,
                        geojson: b.layer.toGeoJSON()
                    })),
                    theme: themeSettings
                };
                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `map_data_${data.date}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                alert('标注数据已保存!');
            });

            document.getElementById('load-btn').addEventListener('click', function() {
                document.getElementById('file-input').click();
            });

            document.getElementById('file-input').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const loadedData = JSON.parse(event.target.result);
                        [...annotations.markers, ...annotations.lines, ...annotations.arrows].forEach(a => {
                            if (a.layer) map.removeLayer(a.layer);
                        });
                        annotations.textBoxes.forEach(t => { 
                            if (t.cleanup) t.cleanup(); 
                            if (t.element) t.element.remove(); 
                        });
                        annotations.markers = [];
                        annotations.lines = [];
                        annotations.arrows = [];
                        annotations.textBoxes = [];
                        
                        allBoundaries.forEach(b => {
                            if (b.layer) boundaryLayers.removeLayer(b.layer);
                        });
                        allBoundaries = [];
                        
                        if (loadedData.theme) {
                            Object.assign(themeSettings, loadedData.theme);
                            document.getElementById('theme-button-color').value = themeSettings.buttonColor;
                            document.getElementById('theme-fill-color').value = themeSettings.fillColor;
                            document.getElementById('theme-fill-opacity').value = themeSettings.fillOpacity * 100;
                            document.getElementById('fill-opacity-value').textContent = Math.round(themeSettings.fillOpacity * 100) + '%';
                            applyTheme();
                        }
                        
                        if (loadedData.boundaries) {
                            loadedData.boundaries.forEach(b => {
                                const layer = L.geoJSON(b.geojson, {
                                    style: {
                                        color: '#ff0000',
                                        weight: 2,
                                        opacity: 0.8,
                                        fillColor: '#ff0000',
                                        fillOpacity: 0.1
                                    }
                                });
                                
                                const boundaryObj = {
                                    name: b.name,
                                    layer: layer,
                                    visible: b.visible !== false,
                                    type: b.type || 'unknown'
                                };
                                
                                allBoundaries.push(boundaryObj);
                                
                                const showCheckbox = document.getElementById('show-boundaries-checkbox');
                                if (showCheckbox && showCheckbox.checked && boundaryObj.visible) {
                                    boundaryLayers.addLayer(layer);
                                }
                            });
                        }
                        
                        const annotationsData = loadedData.annotations;
                        annotationsData.markers.forEach(a => {
                            const markerLayer = createMarker(a.latlng, a.options);
                            annotations.markers.push({ ...a, layer: markerLayer, date: new Date(a.date), zoomLevel: a.zoomLevel || 18 });
                        });
                        annotationsData.lines.forEach(a => {
                            const lineLayer = createLine(a.points, a.options);
                            annotations.lines.push({ ...a, layer: lineLayer, date: new Date(a.date), zoomLevel: a.zoomLevel || 18 });
                        });
                        annotationsData.arrows.forEach(a => {
                            let arrow;
                            if (a.type === 'chevron') {
                                arrow = createChevron(a.points, a.options, map);
                            } else {
                                arrow = createArrow(a.points, a.options);
                            }
                            arrow.zoomLevel = a.zoomLevel || 18;
                            annotations.arrows.push(arrow);
                        });
                        annotationsData.textBoxes.forEach(a => {
                            const box = createTextBox(a.latlng, a.options);
                            box.element.querySelector('textarea').value = a.content;
                            box.zoomLevel = a.zoomLevel || 18;
                            annotations.textBoxes.push(box);
                        });
                        if (loadedData.date) {
                            const [y, m, d] = loadedData.date.split('-').map(Number);
                            currentDate = new Date(y, m - 1, d);
                            updateDateDisplay();
                        } else {
                            updateVisibleAnnotations();
                        }
                        alert('标注数据已加载!');
                    } catch (e) {
                        alert('加载文件失败,请确保文件是有效的 JSON 格式。');
                        console.error('File load error:', e);
                    }
                };
                reader.readAsText(file);
            });
            
            document.getElementById('settings-btn').addEventListener('click', () => {
                document.getElementById('settings-panel').classList.add('show');
            });

            document.querySelector('.close-settings').addEventListener('click', () => {
                document.getElementById('settings-panel').classList.remove('show');
            });

            document.getElementById('theme-button-color').addEventListener('change', (e) => {
                themeSettings.buttonColor = e.target.value;
                applyTheme();
            });

            document.getElementById('theme-fill-color').addEventListener('change', (e) => {
                themeSettings.fillColor = e.target.value;
                applyTheme();
            });

            document.getElementById('theme-fill-opacity').addEventListener('input', (e) => {
                themeSettings.fillOpacity = e.target.value / 100;
                document.getElementById('fill-opacity-value').textContent = e.target.value + '%';
                applyTheme();
            });

            const minZoom = 2;
            const maxZoom = 18;
            const zoomRange = maxZoom - minZoom;
            
            const zoomLevelsContainer = document.getElementById('zoom-levels');
            for (let i = minZoom; i <= maxZoom; i++) {
                const mark = document.createElement('div');
                mark.className = 'zoom-level-mark';
                mark.dataset.zoom = i;
                zoomLevelsContainer.appendChild(mark);
            }

            function updateZoomControl() {
                const currentZoom = map.getZoom();
                const roundedZoom = Math.round(currentZoom);
                const percentage = ((roundedZoom - minZoom) / zoomRange) * 100;
                const thumb = document.getElementById('zoom-slider-thumb');
                const track = document.getElementById('zoom-slider-track');
                thumb.style.bottom = percentage + '%';
                track.style.height = percentage + '%';
                document.querySelectorAll('.zoom-level-mark').forEach(mark => {
                    mark.classList.remove('current');
                    if (parseInt(mark.dataset.zoom) === roundedZoom) {
                        mark.classList.add('current');
                    }
                });
            }

            map.on('zoomend', updateZoomControl);
            map.on('zoomend', updateVisibleAnnotations);
            updateZoomControl();

            const thumb = document.getElementById('zoom-slider-thumb');
            const sliderContainer = document.getElementById('zoom-slider-container');
            let isDragging = false;
            
            thumb.addEventListener('mousedown', (e) => {
                isDragging = true;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const rect = sliderContainer.getBoundingClientRect();
                const y = e.clientY - rect.top;
                const percentage = Math.max(0, Math.min(100, ((rect.height - y) / rect.height) * 100));
                const zoom = minZoom + (percentage / 100) * zoomRange;
                map.setZoom(Math.round(zoom));
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            sliderContainer.addEventListener('click', (e) => {
                if (e.target === thumb) return;
                const rect = sliderContainer.getBoundingClientRect();
                const y = e.clientY - rect.top;
                const percentage = Math.max(0, Math.min(100, ((rect.height - y) / rect.height) * 100));
                const zoom = minZoom + (percentage / 100) * zoomRange;
                map.setZoom(Math.round(zoom));
            });

            applyTheme();
            initYearSelect();
            updateDateDisplay(); 
            updateMapCursor();
            initLocationSearch();
            initGeoJSONUpload();
            initTextToMarker();
            updateLayersPanel();
            document.querySelector('[data-tool="pan"]').style.background = `rgba(${hexToRgb(themeSettings.buttonColor)}, 0.5)`;
        });
    </script>
</body>
</html>
