<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D çƒå½¢åœ°çƒè§‚å¯Ÿå™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/shapefile@0.6.6/dist/shapefile.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a14 100%);
            color: #eee;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(135deg, #16213e 0%, #0f1926 100%);
            padding: 15px 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 10;
            backdrop-filter: blur(10px);
            transform: translateY(-80%);
            transition: transform 0.3s ease-in-out;
        }

        #header.header-expanded,
        #header:hover {
            transform: translateY(0);
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
        
        #controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
            color: #0a0a14;
            padding: 10px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }
        
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
        }
        
        button {
            background: rgba(15, 52, 96, 0.8);
            color: #00d4ff;
            border: 2px solid #00d4ff;
            padding: 8px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        button:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }
        
        #info {
            color: #88ddff;
            font-size: 13px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        #map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #globe-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        svg {
            width: 100%;
            height: 100%;
        }
        
        .sphere {
            fill: url(#ocean-gradient);
        }
        
        .country {
            fill: #1e3a5f;
            stroke: #00d4ff;
            stroke-width: 0.5;
            transition: all 0.3s;
        }
        
        .country:hover {
            fill: #2d5a8f;
            stroke: #00ffff;
            stroke-width: 1.5;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.8));
            cursor: pointer;
        }
        
        .country.selected {
            fill: #ff6b35;
            stroke: #ffaa00;
            stroke-width: 2;
        }
        
        .connection-arc {
            fill: none;
            stroke: #00ffff;
            opacity: 0.6;
            filter: drop-shadow(0 0 8px rgba(0, 255, 255, 0.8));
            pointer-events: none;
        }
        
        .connection-point {
            fill: #ff6b35;
            stroke: #ffaa00;
            stroke-width: 2;
            filter: drop-shadow(0 0 10px rgba(255, 107, 53, 0.8));
        }
        
        .graticule {
            fill: none;
            stroke: rgba(0, 212, 255, 0.2);
            stroke-width: 0.5;
        }

        .text-label {
            fill: #ffd700;
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
        }

        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #334; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #00d4ff; }
        input:checked + .slider:before { transform: translateX(20px); }
        
        #tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.95) 0%, rgba(0, 150, 255, 0.95) 100%);
            color: #0a0a14;
            padding: 10px 16px;
            border-radius: 8px;
            pointer-events: none;
            display: none;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        #legend {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(22, 33, 62, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #00d4ff;
            font-size: 13px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .legend-title {
            font-weight: bold;
            margin-bottom: 12px;
            color: #00d4ff;
            font-size: 15px;
            text-shadow: 0 2px 4px rgba(0, 212, 255, 0.5);
        }
        
        .legend-item {
            margin: 8px 0;
            color: #88ddff;
        }
        
        #rotation-info {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(22, 33, 62, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid #00d4ff;
            font-size: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            color: #88ddff;
            font-family: 'Courier New', monospace;
        }
        
        #debug-info {
            position: absolute;
            top: 120px;
            right: 30px;
            background: rgba(22, 33, 62, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid #ff8800;
            font-size: 11px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            color: #ffaa44;
            font-family: 'Courier New', monospace;
            max-width: 300px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff88;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>ğŸŒ 3D çƒå½¢åœ°çƒè§‚å¯Ÿå™¨</h1>
            <div id="controls">
                <div class="file-input-wrapper">
                    <label for="fileInput" class="file-input-label">ğŸ—ºï¸ åŠ è½½åœ°å›¾ (1:110m)</label>
                    <input type="file" id="fileInput" accept=".geojson,.json,.shp,.zip" />
                </div>
                <button id="resetBtn">ğŸ”„ é‡ç½®è§†å›¾</button>
                <button id="toggleGraticule">ğŸŒ åˆ‡æ¢ç»çº¬ç½‘</button>
                <button id="toggleRotation">â–¶ï¸ å¼€å§‹æ—‹è½¬</button>
                <button id="clearConnections">ğŸ—‘ï¸ æ¸…é™¤è¿æ¥çº¿</button>
                <div style="display: flex; align-items: center; gap: 10px; color: #88ddff;">
                    <label for="lineWidthSlider">çº¿å®½:</label>
                    <input type="range" id="lineWidthSlider" min="1" max="20" value="2.5" step="0.5" style="cursor: pointer;">
                    <span id="lineWidthValue">2.5px</span>
                </div>
                <div style="display: flex; align-items: center; gap: 10px; color: #88ddff;">
                    <label for="connectionDate">æ—¥æœŸ:</label>
                    <input type="date" id="connectionDate" style="background: rgba(15, 52, 96, 0.8); color: #00d4ff; border: 1px solid #00d4ff; border-radius: 4px; padding: 5px;">
                </div>
                <div id="arc-controls" style="display: flex; align-items: center; gap: 15px; background: rgba(10,20,40,0.7); padding: 8px 12px; border-radius: 8px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label class="switch">
                            <input type="checkbox" id="arcModeToggle">
                            <span class="slider round"></span>
                        </label>
                        <span>æŠ›ç‰©çº¿æ¨¡å¼</span>
                    </div>
                    <div id="arc-height-control" style="display: none; align-items: center; gap: 8px;">
                        <label for="arcHeightSlider">é«˜åº¦:</label>
                        <input type="range" id="arcHeightSlider" min="0" max="1" value="0.2" step="0.01" style="cursor: pointer;">
                        <span id="arcHeightValue">0.2</span>
                    </div>
                </div>
                <div id="location-search-controls" style="display: flex; align-items: center; gap: 10px; background: rgba(10,20,40,0.7); padding: 8px 12px; border-radius: 8px;">
                    <div class="file-input-wrapper">
                        <label for="dbInput" class="file-input-label" style="font-size: 12px; padding: 6px 12px;">åŠ è½½åœ°ç†æ•°æ®åº“</label>
                        <input type="file" id="dbInput" accept=".json" />
                    </div>
                    <input type="text" id="locationSearch" placeholder="æœç´¢åŸå¸‚/çœä»½..." style="background: rgba(15, 52, 96, 0.8); color: #00d4ff; border: 1px solid #00d4ff; border-radius: 4px; padding: 5px;">
                    <button id="searchBtn">ğŸ” å®šä½</button>
                </div>
                <span id="info">è¯·åŠ è½½åœ°å›¾åŒ…æˆ–å•ç‹¬åŠ è½½å„çº§åˆ«åœ°å›¾</span>
            </div>
        </div>
        
        <div id="map-container">
            <div id="globe-container">
                <svg id="globe"></svg>
            </div>
            <div id="tooltip"></div>
            <div id="legend">
                <div class="legend-title">ğŸ® æ“ä½œè¯´æ˜</div>
                <div class="legend-item">ğŸ–±ï¸ æ‹–æ‹½: æ—‹è½¬åœ°çƒï¼ˆä»»æ„æ–¹å‘ï¼‰</div>
                <div class="legend-item">ğŸ–±ï¸ æ»šè½®: ç¼©æ”¾è§†å›¾</div>
                <div class="legend-item">ğŸ–±ï¸ æ‚¬åœ: æŸ¥çœ‹å›½å®¶</div>
                <div class="legend-item">ğŸ‘† ç‚¹å‡»: é€‰æ‹©ä¸¤ä¸ªåœ°ç‚¹è¿çº¿</div>
                <div class="legend-item">â¸ï¸ æŒ‰é’®: æ§åˆ¶è‡ªåŠ¨æ—‹è½¬</div>
            </div>
            <div id="rotation-info">
                <span class="status-indicator"></span>
                <span id="rotation-status">æ—‹è½¬å·²æš‚åœ</span>
            </div>
            <div id="debug-info">
                <div><strong>ğŸ” è°ƒè¯•ä¿¡æ¯</strong></div>
                <div>ç»åº¦: <span id="debug-lon">0Â°</span></div>
                <div>çº¬åº¦: <span id="debug-lat">0Â°</span></div>
                <div>ç¼©æ”¾: <span id="debug-zoom">1.0x</span></div>
                <div>å½“å‰åœ°å›¾: <span id="debug-lod">æœªåŠ è½½</span></div>
                <div>å¯è§å›½å®¶: <span id="debug-visible">0</span></div>
                <div>æ€»å›½å®¶æ•°: <span id="debug-total">0</span></div>
                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ffaa44;">
                    <strong>ğŸ“ è¿æ¥çº¿æ¨¡å¼</strong><br>
                    <span id="connection-mode">å¾…é€‰æ‹©èµ·ç‚¹</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const svg = d3.select("#globe");
        const globeContainer = document.getElementById('globe-container');
        let width, height, initialScale;

        // åˆ›å»ºæ¸å˜
        const defs = svg.append("defs");
        const oceanGradient = defs.append("radialGradient")
            .attr("id", "ocean-gradient");
        oceanGradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", "#1a3d5c");
        oceanGradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", "#0a1929");
        
        const projection = d3.geoOrthographic()
            .rotate([0, 0, 0])
            .clipAngle(90);
        
        const path = d3.geoPath().projection(projection);
        const graticule = d3.geoGraticule();
        
        // ç»˜åˆ¶çƒä½“
        svg.append("path")
            .datum({type: "Sphere"})
            .attr("class", "sphere")
            .attr("d", path);
        
        const g = svg.append("g");
        const connectionsGroup = svg.append("g").attr("class", "connections");
        const selectionGroup = svg.append("g").attr("class", "selection-points");
        
        // ç»˜åˆ¶ç»çº¬ç½‘
        let graticulePath = g.append("path")
            .datum(graticule)
            .attr("class", "graticule")
            .attr("d", path);
        
        let showGraticule = true;
        let isRotating = false;
        let rotation = [0, 0];
        
        let currentGeoJSON = null;
        let selectedPoints = [];
        let connections = [];
        let locationDB = [];
        
        // æ¸²æŸ“å½“å‰åœ°å›¾
        function renderCurrentMap() {
            if (!currentGeoJSON) return;
            
            g.selectAll(".country").remove();
            
            g.selectAll(".country")
                .data(currentGeoJSON.features)
                .enter()
                .append("path")
                .attr("class", "country")
                .attr("d", path)
                .on("click", function(event, d) {
                    event.stopPropagation();
                    const centroid = d3.geoCentroid(d);
                    const name = d.properties.NAME || d.properties.name || 
                               d.properties.ADMIN || d.properties.admin || "æœªçŸ¥";

                    if (selectedPoints.length === 0) {
                        selectedPoints.push(centroid);
                        d3.select(this).classed("selected", true);
                        updateConnectionMode();
                        document.getElementById("info").textContent = `âœ… å·²é€‰æ‹©èµ·ç‚¹: ${name}`;
                        
                        // Immediately draw the first selection point
                        selectionGroup.append("circle")
                            .attr("class", "connection-point selection-point")
                            .attr("cx", projection(centroid)[0])
                            .attr("cy", projection(centroid)[1])
                            .attr("r", 5);

                    } else if (selectedPoints.length === 1) {
                        selectedPoints.push(centroid);
                        document.getElementById("info").textContent = `âœ… å·²åˆ›å»ºè¿æ¥çº¿åˆ°: ${name}`;
                        
                        // Clear temporary selection point
                        selectionGroup.selectAll("*").remove();
                        
                        drawConnection(selectedPoints[0], selectedPoints[1]);
                        
                        selectedPoints = [];
                        g.selectAll(".country").classed("selected", false);
                        updateConnectionMode();
                    }
                })
                .on("mouseover", function(event, d) {
                    const name = d.properties.NAME || d.properties.name || 
                               d.properties.ADMIN || d.properties.admin || 
                               d.properties.NAME_LONG || d.properties.NAME_EN || 
                               d.properties.COUNTRY || "æœªçŸ¥";
                    tooltip
                        .style("display", "block")
                        .html(name);
                })
                .on("mousemove", function(event) {
                    tooltip
                        .style("left", (event.pageX + 15) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    tooltip.style("display", "none");
                });
        }
        
        // æ›´æ–°è¿æ¥çº¿çŠ¶æ€æ˜¾ç¤º
        function updateConnectionMode() {
            const modeText = document.getElementById('connection-mode');
            if (selectedPoints.length === 0) {
                modeText.textContent = 'å¾…é€‰æ‹©èµ·ç‚¹';
                modeText.style.color = '#ffaa44';
            } else if (selectedPoints.length === 1) {
                modeText.textContent = 'å·²é€‰èµ·ç‚¹ï¼Œé€‰æ‹©ç»ˆç‚¹';
                modeText.style.color = '#00ff88';
            }
        }
        
        // ç»˜åˆ¶è¿æ¥çº¿
        function drawConnection(point1, point2) {
            const date = document.getElementById('connectionDate').value;
            if (!date) {
                alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ—¥æœŸ");
                return;
            }

            // ä½¿ç”¨ D3 çš„çƒé¢æ’å€¼åˆ›å»ºå¤§åœ†å¼§
            const interpolate = d3.geoInterpolate(point1, point2);
            
            // ç”Ÿæˆå¼§çº¿ä¸Šçš„ç‚¹
            const points = [];
            for (let i = 0; i <= 100; i++) {
                points.push(interpolate(i / 100));
            }
            
            // åˆ›å»º LineString
            const arcLine = {
                type: "LineString",
                coordinates: points
            };
            
            const currentLineWidth = document.getElementById("lineWidthSlider").value;

            const connectionId = `conn-${Date.now()}`;
            const connectionData = {
                id: connectionId,
                point1,
                point2,
                arcLine,
                date,
                text: ''
            };

            const connectionGroup = connectionsGroup.append("g")
                .datum(connectionData)
                .attr("class", "connection-group")
                .attr("id", connectionId);

            // ç»˜åˆ¶å¼§çº¿
            connectionGroup.append("path")
                .datum(d => d.arcLine)
                .attr("class", "connection-arc")
                .attr("d", path)
                .style("stroke-width", `${currentLineWidth}px`)
                .on('dblclick', function(event) {
                    event.stopPropagation();
                    const parentData = d3.select(this.parentNode).datum();
                    const newText = prompt("è¯·è¾“å…¥æ ‡ç­¾æ–‡æœ¬:", parentData.text);
                    if (newText !== null) {
                        parentData.text = newText;
                        renderOrUpdateTextLabels();
                    }
                });
            
            // ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹æ ‡è®°
            connectionGroup.append("circle")
                .attr("class", "connection-point start-point")
                .attr("r", 5);

            connectionGroup.append("circle")
                .attr("class", "connection-point end-point")
                .attr("r", 5);
            
            // ä¿å­˜è¿æ¥
            connections.push(connectionData);
        }
        
        function generateArcPath(d) {
            const arcMode = document.getElementById('arcModeToggle').checked;
            if (!arcMode) {
                return path(d.arcLine);
            }

            const arcHeight = +document.getElementById('arcHeightSlider').value;
            const interpolate = d3.geoInterpolate(d.point1, d.point2);
            const midPoint = interpolate(0.5);
            const startPoint = projection(d.point1);
            const endPoint = projection(d.point2);

            if (!startPoint || !endPoint) return "M0,0";

            const controlPoint = projection(midPoint);
            const dist = Math.sqrt(Math.pow(endPoint[0] - startPoint[0], 2) + Math.pow(endPoint[1] - startPoint[1], 2));
            
            controlPoint[1] -= dist * arcHeight;

            return `M${startPoint[0]},${startPoint[1]} Q${controlPoint[0]},${controlPoint[1]} ${endPoint[0]},${endPoint[1]}`;
        }

        // æ›´æ–°æ‰€æœ‰è¿æ¥çº¿çš„ä½ç½®
        function updateConnections() {
            const center = [-projection.rotate()[0], -projection.rotate()[1]];

            connectionsGroup.selectAll('.connection-group')
                .each(function(d) {
                    const group = d3.select(this);
                    const isVisible1 = d3.geoDistance(d.point1, center) < Math.PI / 2;
                    const isVisible2 = d3.geoDistance(d.point2, center) < Math.PI / 2;
                    const midPoint = d3.geoInterpolate(d.point1, d.point2)(0.5);
                    const isMidVisible = d3.geoDistance(midPoint, center) < Math.PI / 2;

                    group.style('display', isVisible1 || isVisible2 || isMidVisible ? 'block' : 'none');
                    
                    group.select('.connection-arc').attr('d', generateArcPath(d));

                    const p1 = projection(d.point1);
                    group.select('.start-point')
                        .attr('cx', p1 ? p1[0] : -999)
                        .attr('cy', p1 ? p1[1] : -999)
                        .style('display', isVisible1 ? 'block' : 'none');

                    const p2 = projection(d.point2);
                    group.select('.end-point')
                        .attr('cx', p2 ? p2[0] : -999)
                        .attr('cy', p2 ? p2[1] : -999)
                        .style('display', isVisible2 ? 'block' : 'none');
                });
            
            renderOrUpdateTextLabels();
            
            // Update temporary selection point
            if (selectedPoints.length === 1) {
                const p = projection(selectedPoints[0]);
                selectionGroup.select('.selection-point')
                    .attr('cx', p[0])
                    .attr('cy', p[1]);
            }

            // Also update the main country paths
            g.selectAll(".country").attr("d", path);
            graticulePath.attr("d", path);
        }

        function renderOrUpdateTextLabels() {
            connectionsGroup.selectAll('.connection-group').each(function(d) {
                const group = d3.select(this);
                let label = group.select('.text-label');

                if (d.text && label.empty()) {
                    label = group.append('text').attr('class', 'text-label');
                }

                if (d.text) {
                    const p1 = d.point1;
                    const p2 = d.point2;
                    const midPoint = d3.geoInterpolate(p1, p2)(0.5);
                    const center = [-projection.rotate()[0], -projection.rotate()[1]];
                    const isVisible = d3.geoDistance(midPoint, center) < Math.PI / 2;
                    
                    if (isVisible) {
                        const pos = projection(midPoint);
                        label.attr('transform', `translate(${pos[0]}, ${pos[1]})`)
                             .text(d.text)
                             .style('display', 'block');
                    } else {
                        label.style('display', 'none');
                    }
                } else if (!label.empty()) {
                    label.remove();
                }
            });
        }
        
        // æ¸…é™¤æ‰€æœ‰è¿æ¥çº¿
        function clearConnections() {
            connectionsGroup.selectAll("*").remove();
            selectionGroup.selectAll("*").remove();
            connections = [];
            selectedPoints = [];
            g.selectAll(".country").classed("selected", false);
            updateConnectionMode();
        }
        
        // æ›´æ–°è°ƒè¯•ä¿¡æ¯
        function updateDebugInfo() {
            const rotate = projection.rotate();
            document.getElementById('debug-lon').textContent = rotate[0].toFixed(1) + 'Â°';
            document.getElementById('debug-lat').textContent = rotate[1].toFixed(1) + 'Â°';
            
            if (initialScale) {
                const scale = projection.scale() / initialScale;
                document.getElementById('debug-zoom').textContent = scale.toFixed(2) + 'x';
            }
            
            if (currentGeoJSON) {
                const visible = g.selectAll('.country').nodes().filter(node => {
                    const display = d3.select(node).style('display');
                    const visibility = d3.select(node).style('visibility');
                    return display !== 'none' && visibility !== 'hidden';
                }).length;
                
                document.getElementById('debug-visible').textContent = visible;
                document.getElementById('debug-total').textContent = currentGeoJSON.features.length;
            }
            
            // æ›´æ–°è¿æ¥çº¿ä½ç½®
            updateConnections();
        }
        
        // è‡ªåŠ¨æ—‹è½¬
        const rotationSpeed = 0.3;
        let rotationTimer = d3.timer(function(elapsed) {
            if (isRotating) {
                rotation[0] = (rotation[0] + rotationSpeed) % 360;
                projection.rotate(rotation);
                svg.selectAll(".sphere, .country, .graticule").attr("d", path);
                updateConnections(); // Specifically update connections
                updateDebugInfo();
            }
        });
        
        // æ‹–æ‹½æ—‹è½¬ - æ¢å¤ä¸Šä¸‹å·¦å³æ—‹è½¬
        const drag = d3.drag()
            .on("start", function(event) {
                isRotating = false;
                updateRotationStatus();
            })
            .on("drag", function(event) {
                const rotate = projection.rotate();
                const k = 75 / projection.scale();
                // æ¢å¤å®Œæ•´çš„æ—‹è½¬ï¼šå·¦å³å’Œä¸Šä¸‹
                projection.rotate([
                    rotate[0] + event.dx * k,
                    rotate[1] - event.dy * k  // æ¢å¤çº¬åº¦æ—‹è½¬
                ]);
                rotation = projection.rotate();
                svg.selectAll(".sphere, .country, .graticule").attr("d", path);
                updateDebugInfo();
            });
        
        svg.call(drag);
        
        // ç¼©æ”¾
        const zoom = d3.zoom()
            .scaleExtent([0.5, 100])
            .on("zoom", function(event) {
                if (!initialScale) return;
                projection.scale(initialScale * event.transform.k);
                
                svg.selectAll(".sphere, .country, .graticule").attr("d", path);
                updateDebugInfo();
            });
        
        svg.call(zoom);
        
        const tooltip = d3.select("#tooltip");
        
        function renderGeoJSON(geojson) {
            console.log("æ¸²æŸ“åœ°å›¾æ•°æ®:", geojson);
            
            if (!geojson || !geojson.features || geojson.features.length === 0) {
                alert("åœ°å›¾æ•°æ®ä¸ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¡®");
                document.getElementById("info").textContent = "âŒ åœ°å›¾æ•°æ®æ— æ•ˆ";
                return;
            }
            
            currentGeoJSON = geojson;
            renderCurrentMap();
            
            console.log("å·²æ¸²æŸ“", geojson.features.length, "ä¸ªè¦ç´ ");
            document.getElementById("info").textContent = 
                `âœ… å·²åŠ è½½åœ°å›¾ (${geojson.features.length} ä¸ªåœ°ç†è¦ç´ )`;
            
            // åˆå§‹åŒ–è°ƒè¯•ä¿¡æ¯
            updateDebugInfo();
        }
        
        function loadGeoJSON(file) {
            document.getElementById("info").textContent = `â³ æ­£åœ¨åŠ è½½ GeoJSON...`;
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const geojson = JSON.parse(e.target.result);
                    console.log(`GeoJSON è§£ææˆåŠŸ:`, geojson);
                    renderGeoJSON(geojson);
                } catch (error) {
                    console.error("GeoJSON è§£æé”™è¯¯:", error);
                    alert("GeoJSON æ–‡ä»¶è§£æå¤±è´¥: " + error.message);
                    document.getElementById("info").textContent = "âŒ åŠ è½½å¤±è´¥";
                }
            };
            
            reader.onerror = function() {
                alert("GeoJSON æ–‡ä»¶è¯»å–é”™è¯¯");
                document.getElementById("info").textContent = "âŒ æ–‡ä»¶è¯»å–é”™è¯¯";
            };
            
            reader.readAsText(file);
        }
        
        function loadShapefile(file) {
            document.getElementById("info").textContent = `â³ æ­£åœ¨åŠ è½½ Shapefile...`;
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    console.log(`å¼€å§‹è§£æ Shapefile, å¤§å°:`, arrayBuffer.byteLength);
                    
                    if (typeof shapefile === 'undefined') {
                        alert("Shapefile åº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•æˆ–ä½¿ç”¨ GeoJSON æ ¼å¼");
                        document.getElementById("info").textContent = "âŒ Shapefile åº“æœªåŠ è½½";
                        return;
                    }
                    
                    shapefile.open(arrayBuffer)
                        .then(source => {
                            const features = [];
                            
                            function readNext() {
                                return source.read().then(result => {
                                    if (result.done) {
                                        return features;
                                    }
                                    features.push(result.value);
                                    return readNext();
                                });
                            }
                            
                            return readNext();
                        })
                        .then(function(features) {
                            console.log(`è¯»å–åˆ°`, features.length, "ä¸ªè¦ç´ ");
                            const geojson = {
                                type: "FeatureCollection",
                                features: features
                            };
                            renderGeoJSON(geojson);
                        })
                        .catch(function(error) {
                            console.error("Shapefile è§£æé”™è¯¯:", error);
                            alert("Shapefile è§£æå¤±è´¥: " + error.message);
                            document.getElementById("info").textContent = "âŒ Shapefile åŠ è½½å¤±è´¥";
                        });
                } catch (error) {
                    console.error("è¯»å–æ–‡ä»¶é”™è¯¯:", error);
                    alert("è¯»å–æ–‡ä»¶å¤±è´¥: " + error.message);
                    document.getElementById("info").textContent = "âŒ æ–‡ä»¶è¯»å–å¤±è´¥";
                }
            };
            
            reader.onerror = function() {
                alert("æ–‡ä»¶è¯»å–é”™è¯¯");
                document.getElementById("info").textContent = "âŒ æ–‡ä»¶è¯»å–é”™è¯¯";
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        function parseAndLoadShapefile(zipBuffer, filenameHint) {
            return shapefile.open(zipBuffer)
                .then(source => {
                    const features = [];
                    function readNext() {
                        return source.read().then(result => {
                            if (result.done) return features;
                            features.push(result.value);
                            return readNext();
                        });
                    }
                    return readNext();
                })
                .then(features => {
                    const geojson = { type: "FeatureCollection", features: features };
                    renderGeoJSON(geojson);
                })
                .catch(error => {
                    console.error(`åŠ è½½åœ°å›¾ (${filenameHint}) å¤±è´¥:`, error);
                    alert(`åŠ è½½åœ°å›¾ (${filenameHint}) å¤±è´¥: ${error.message}`);
                });
        }

        function loadZipFile(file) {
            document.getElementById("info").textContent = `â³ æ­£åœ¨åŠ è½½ ZIP æ–‡ä»¶...`;
            const reader = new FileReader();
            reader.onload = (e) => parseAndLoadShapefile(e.target.result, file.name);
            reader.onerror = () => {
                alert("æ–‡ä»¶è¯»å–é”™è¯¯");
                document.getElementById("info").textContent = "âŒ æ–‡ä»¶è¯»å–é”™è¯¯";
            };
            reader.readAsArrayBuffer(file);
        }
        
        document.getElementById("fileInput").addEventListener("change", function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const fileName = file.name.toLowerCase();
            
            if (fileName.endsWith('.geojson') || fileName.endsWith('.json')) {
                loadGeoJSON(file);
            } else if (fileName.endsWith('.shp')) {
                loadShapefile(file);
            } else if (fileName.endsWith('.zip')) {
                loadZipFile(file);
            } else {
                alert("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼");
            }
        });
        
        document.getElementById("resetBtn").addEventListener("click", function() {
            svg.transition()
                .duration(750)
                .call(zoom.transform, d3.zoomIdentity);
        });
        
        document.getElementById("toggleGraticule").addEventListener("click", function() {
            showGraticule = !showGraticule;
            graticulePath.style("display", showGraticule ? "block" : "none");
        });
        
        document.getElementById("toggleRotation").addEventListener("click", function() {
            isRotating = !isRotating;
            updateRotationStatus();
        });
        
        document.getElementById("clearConnections").addEventListener("click", function() {
            clearConnections();
            document.getElementById("info").textContent = "ğŸ—‘ï¸ å·²æ¸…é™¤æ‰€æœ‰è¿æ¥çº¿";
        });
        
        const lineWidthSlider = document.getElementById("lineWidthSlider");
        const lineWidthValue = document.getElementById("lineWidthValue");

        lineWidthSlider.addEventListener("input", function() {
            const newWidth = this.value;
            lineWidthValue.textContent = `${newWidth}px`;
            connectionsGroup.selectAll(".connection-arc").style("stroke-width", `${newWidth}px`);
        });

        document.getElementById('connectionDate').addEventListener('change', function() {
            // When date changes, clear any pending selections
            if (selectedPoints.length > 0) {
                selectedPoints = [];
                g.selectAll(".country").classed("selected", false);
                updateConnectionMode();
                document.getElementById("info").textContent = "æ—¥æœŸå·²æ›´æ”¹ï¼Œè¯·é‡æ–°é€‰æ‹©èµ·ç‚¹ã€‚";
            }
            filterConnectionsByDate(this.value);
        });

        document.getElementById('arcModeToggle').addEventListener('change', function() {
            const arcHeightControl = document.getElementById('arc-height-control');
            arcHeightControl.style.display = this.checked ? 'flex' : 'none';
            updateConnections();
        });

        document.getElementById('arcHeightSlider').addEventListener('input', function() {
            document.getElementById('arcHeightValue').textContent = this.value;
            updateConnections();
        });

        document.getElementById('dbInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    locationDB = JSON.parse(e.target.result);
                    document.getElementById('info').textContent = `âœ… åœ°ç†æ•°æ®åº“å·²åŠ è½½ (${locationDB.length} ä¸ªå›½å®¶).`;
                    alert("åœ°ç†æ•°æ®åº“åŠ è½½æˆåŠŸï¼");
                } catch (error) {
                    alert("æ•°æ®åº“æ–‡ä»¶è§£æå¤±è´¥: " + error.message);
                }
            };
            reader.readAsText(file);
        });

        document.getElementById('searchBtn').addEventListener('click', function() {
            const query = document.getElementById('locationSearch').value.trim();
            if (!query) return;
            if (locationDB.length === 0) {
                alert("è¯·å…ˆåŠ è½½åœ°ç†æ•°æ®åº“ã€‚");
                return;
            }
            searchLocation(query);
        });

        function filterConnectionsByDate(selectedDate) {
            connectionsGroup.selectAll('.connection-group')
                .style('display', d => (d.date === selectedDate) ? 'block' : 'none');
        }

        function normalizeName(name) {
            return name.toLowerCase()
                .replace(/sheng|province|autonomous region|special administrative region/g, '')
                .trim();
        }

        function searchLocation(query) {
            const normalizedQuery = normalizeName(query);
            let found = null;

            // Search for countries
            for (const country of locationDB) {
                if (normalizeName(country.name).includes(normalizedQuery)) {
                    found = { ...country, level: 'country' };
                    break;
                }
            }

            // Search for states if no country found
            if (!found) {
                for (const country of locationDB) {
                    for (const state of country.states) {
                        if (normalizeName(state.name).includes(normalizedQuery)) {
                            found = { ...state, level: 'state' };
                            break;
                        }
                    }
                    if (found) break;
                }
            }

            // Search for cities if still not found
            if (!found) {
                for (const country of locationDB) {
                    for (const state of country.states) {
                        for (const city of state.cities) {
                            if (normalizeName(city.name).includes(normalizedQuery)) {
                                found = { ...city, level: 'city' };
                                break;
                            }
                        }
                        if (found) break;
                    }
                    if (found) break;
                }
            }

            if (found) {
                g.selectAll(".country").classed("selected", false);
                
                const targetRotation = [-found.lon, -found.lat];
                const targetScale = d3.zoomIdentity.translate(width / 2, height / 2).scale(
                    found.level === 'country' ? 2.5 : (found.level === 'state' ? 5 : 10)
                );

                svg.transition()
                    .duration(1250)
                    .call(zoom.transform, targetScale)
                    .tween("rotate", function() {
                        const r = d3.interpolate(projection.rotate(), targetRotation);
                        return function(t) {
                            projection.rotate(r(t));
                            updateConnections();
                        };
                    })
                    .on("end", () => {
                        // Highlight the corresponding feature
                        const normalizedFoundName = normalizeName(found.name);
                        let highlighted = g.selectAll(".country")
                            .filter(function(d) {
                                const featureName = d.properties.NAME || d.properties.name || 
                                                    d.properties.ADMIN || d.properties.admin || "";
                                return normalizeName(featureName).includes(normalizedFoundName);
                            });
                        
                        if (highlighted.empty() && mapLOD['110m']) {
                            const layerToSearch = d3.select(document.createElement("g"));
                            layerToSearch.selectAll(".country")
                                .data(mapLOD['110m'].features)
                                .enter()
                                .append("path")
                                .attr("class", "country");
                            
                            highlighted = layerToSearch.selectAll(".country")
                                .filter(function(d) {
                                    const featureName = d.properties.NAME || d.properties.name || 
                                                        d.properties.ADMIN || d.properties.admin || "";
                                    return normalizeName(featureName).includes(normalizedFoundName);
                                });
                        }

                        if (!highlighted.empty()) {
                            g.selectAll(".country")
                                .filter(function(d) {
                                    const featureName = d.properties.NAME || d.properties.name || 
                                                        d.properties.ADMIN || d.properties.admin || "";
                                    return normalizeName(featureName).includes(normalizedFoundName);
                                })
                                .classed("selected", true);
                            document.getElementById('info').textContent = `âœ… å·²å®šä½å¹¶é«˜äº®: ${found.name}`;
                        } else {
                            document.getElementById('info').textContent = `â„¹ï¸ å·²å®šä½åˆ° ${found.name}ï¼Œä½†åœ¨å½“å‰åœ°å›¾æœªæ‰¾åˆ°è¾¹ç•Œã€‚`;
                        }
                    });

            } else {
                alert("æœªæ‰¾åˆ°æŒ‡å®šä½ç½®ã€‚");
            }
        }
        
        function updateRotationStatus() {
            const btn = document.getElementById("toggleRotation");
            const status = document.getElementById("rotation-status");
            if (isRotating) {
                btn.textContent = "â¸ï¸ æš‚åœæ—‹è½¬";
                status.textContent = "è‡ªåŠ¨æ—‹è½¬ä¸­...";
            } else {
                btn.textContent = "â–¶ï¸ å¼€å§‹æ—‹è½¬";
                status.textContent = "æ—‹è½¬å·²æš‚åœ";
            }
        }
        
        // Initial call to set button text correctly
        updateRotationStatus();
        
        function handleResize() {
            width = globeContainer.clientWidth;
            height = globeContainer.clientHeight;
            
            svg.attr('width', width).attr('height', height);
            
            initialScale = Math.min(width, height) / 2.2;
            
            const currentZoom = d3.zoomTransform(svg.node());
            
            projection
                .scale(initialScale * currentZoom.k)
                .translate([width / 2, height / 2]);

            svg.selectAll(".sphere, .country, .graticule").attr("d", path);
            updateConnections();
        }

        window.addEventListener('resize', handleResize);
        handleResize(); // Initial call

        // Set default date to today
        document.getElementById('connectionDate').valueAsDate = new Date();
    </script>
</body>
</html>