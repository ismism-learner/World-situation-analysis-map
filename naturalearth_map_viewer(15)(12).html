<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D çƒå½¢åœ°çƒè§‚å¯Ÿå™¨ - å¤šå›¾å±‚</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/shapefile@0.6.6/dist/shapefile.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a14 100%);
            color: #eee;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(135deg, #16213e 0%, #0f1926 100%);
            padding: 15px 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 10;
            backdrop-filter: blur(10px);
            transform: translateY(-85%);
            transition: transform 0.3s ease-in-out;
        }

        #header.header-expanded,
        #header:hover {
            transform: translateY(0);
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: bold;
        }
        
        #controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
            color: #0a0a14;
            padding: 10px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }
        
        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
        }
        
        button {
            background: rgba(15, 52, 96, 0.8);
            color: #00d4ff;
            border: 2px solid #00d4ff;
            padding: 8px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        button:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }
        
        #info {
            color: #88ddff;
            font-size: 13px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        #map-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #globe-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        svg {
            width: 100%;
            height: 100%;
        }
        
        .sphere {
            fill: url(#ocean-gradient);
        }
        
        .layer-country {
            fill: #1e3a5f;
            stroke: #00d4ff;
            stroke-width: 0.5;
            transition: all 0.3s;
        }
        
        .layer-country:hover {
            fill: #2d5a8f;
            stroke: #00ffff;
            stroke-width: 1.5;
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.8));
            cursor: pointer;
        }
        
        .layer-country.selected {
            fill: #ff6b35;
            stroke: #ffaa00;
            stroke-width: 2;
        }
        
        .layer-state {
            fill: none;
            stroke: #00d4ff;
            stroke-width: 0.3;
            opacity: 0.6;
        }
        
        .layer-boundary {
            fill: none;
            stroke: #ff6b35;
            stroke-width: 1;
            opacity: 0.8;
        }
        
        .layer-city {
            fill: #ffaa00;
            stroke: #fff;
            stroke-width: 1;
        }
        
        .layer-city:hover {
            fill: #ff6b35;
            r: 4;
            cursor: pointer;
        }
        
        .connection-arc {
            fill: none;
            stroke: #00ffff;
            opacity: 0.6;
            filter: drop-shadow(0 0 8px rgba(0, 255, 255, 0.8));
            pointer-events: all;
            cursor: pointer;
        }
        
        .connection-point {
            fill: #ff6b35;
            stroke: #ffaa00;
            stroke-width: 2;
            filter: drop-shadow(0 0 10px rgba(255, 107, 53, 0.8));
        }
        
        .graticule {
            fill: none;
            stroke: rgba(0, 212, 255, 0.2);
            stroke-width: 0.5;
        }
        
        #tooltip {
            position: absolute;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.95) 0%, rgba(0, 150, 255, 0.95) 100%);
            color: #0a0a14;
            padding: 10px 16px;
            border-radius: 8px;
            pointer-events: none;
            display: none;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        #layer-panel {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(22, 33, 62, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #00d4ff;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 280px;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .panel-title {
            font-weight: bold;
            margin-bottom: 15px;
            color: #00d4ff;
            font-size: 16px;
            text-shadow: 0 2px 4px rgba(0, 212, 255, 0.5);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .layer-category {
            margin-bottom: 20px;
        }
        
        .category-header {
            color: #88ddff;
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.3);
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            margin: 5px 0;
            background: rgba(15, 52, 96, 0.4);
            border-radius: 6px;
            transition: all 0.3s;
        }
        
        .layer-item:hover {
            background: rgba(0, 212, 255, 0.15);
        }
        
        .layer-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .layer-label {
            color: #88ddff;
            font-size: 12px;
            cursor: pointer;
            flex: 1;
        }
        
        .layer-status {
            font-size: 10px;
            color: #ff8800;
        }
        
        .layer-status.loaded {
            color: #00ff88;
        }
        
        .file-upload-btn {
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid #00d4ff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            color: #00d4ff;
        }
        
        .file-upload-btn:hover {
            background: rgba(0, 212, 255, 0.3);
        }
        
        #legend {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(22, 33, 62, 0.85);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #00d4ff;
            font-size: 13px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .legend-title {
            font-weight: bold;
            margin-bottom: 12px;
            color: #00d4ff;
            font-size: 15px;
            text-shadow: 0 2px 4px rgba(0, 212, 255, 0.5);
        }
        
        .legend-item {
            margin: 8px 0;
            color: #88ddff;
        }
        
        #rotation-info {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(22, 33, 62, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid #00d4ff;
            font-size: 12px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            color: #88ddff;
            font-family: 'Courier New', monospace;
        }
        
        #search-panel {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(22, 33, 62, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #00d4ff;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            min-width: 300px;
            display: none;
        }
        
        #search-panel.active {
            display: block;
        }
        
        #searchInput {
            width: 100%;
            padding: 10px 15px;
            background: rgba(15, 52, 96, 0.8);
            border: 2px solid #00d4ff;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            outline: none;
        }
        
        #searchInput:focus {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        
        #searchResults {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .search-result-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(15, 52, 96, 0.6);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid transparent;
        }
        
        .search-result-item:hover {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
            transform: translateX(5px);
        }
        
        .result-name {
            color: #00d4ff;
            font-weight: bold;
            font-size: 14px;
        }
        
        .result-path {
            color: #88ddff;
            font-size: 11px;
            margin-top: 3px;
        }
        
        .connection-label {
            fill: #fff;
            font-size: 14px;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 0 0 8px rgba(0, 0, 0, 0.5);
        }
        
        .connection-label-bg {
            fill: rgba(0, 212, 255, 0.9);
            rx: 6;
            ry: 6;
        }
        
        .label-input {
            position: absolute;
            background: rgba(0, 212, 255, 0.95);
            border: 2px solid #fff;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: bold;
            color: #0a0a14;
            outline: none;
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.5);
            z-index: 1000;
        }
        
        .boundary-highlight {
            fill: none;
            stroke: #ff6b35;
            stroke-width: 3;
            stroke-dasharray: 10, 5;
            animation: dash 20s linear infinite;
            filter: drop-shadow(0 0 10px rgba(255, 107, 53, 0.8));
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff88;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes dash {
            to {
                stroke-dashoffset: -1000;
            }
        }
        
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(15, 52, 96, 0.3);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.5);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 212, 255, 0.8);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>ğŸŒ 3D çƒå½¢åœ°çƒè§‚å¯Ÿå™¨ - å¤šå›¾å±‚ç³»ç»Ÿ</h1>
            <div id="controls">
                <div class="file-input-wrapper">
                    <label for="culturalPackInput" class="file-input-label">ğŸ“¦ åŠ è½½ Cultural Pack (ZIP)</label>
                    <input type="file" id="culturalPackInput" accept=".zip" />
                </div>
                <button id="resetBtn">ğŸ”„ é‡ç½®è§†å›¾</button>
                <button id="toggleGraticule">ğŸŒ åˆ‡æ¢ç»çº¬ç½‘</button>
                <button id="toggleRotation">â–¶ï¸ å¼€å§‹æ—‹è½¬</button>
                <button id="clearConnections">ğŸ—‘ï¸ æ¸…é™¤è¿æ¥çº¿</button>
                <button id="toggleArcMode">ğŸŒˆ åˆ‡æ¢æŠ›ç‰©çº¿</button>
                <div style="display: flex; align-items: center; gap: 10px; color: #88ddff;">
                    <label for="lineWidthSlider">çº¿å®½:</label>
                    <input type="range" id="lineWidthSlider" min="1" max="20" value="2.5" step="0.5" style="cursor: pointer;">
                    <span id="lineWidthValue">2.5px</span>
                </div>
                <div class="file-input-wrapper">
                    <label for="citiesDbInput" class="file-input-label" style="font-size: 12px; padding: 6px 12px;">ğŸ“ åŠ è½½åŸå¸‚æ•°æ®åº“</label>
                    <input type="file" id="citiesDbInput" accept=".json" />
                </div>
                <span id="info">è¯·åœ¨å³ä¾§å›¾å±‚é¢æ¿åŠ è½½åœ°å›¾æ•°æ®</span>
            </div>
        </div>
        
        <div id="map-container">
            <div id="globe-container">
                <svg id="globe"></svg>
            </div>
            <div id="tooltip"></div>
            <div id="search-panel">
                <input type="text" id="searchInput" placeholder="ğŸ” æœç´¢åŸå¸‚ã€å·/çœã€å›½å®¶..." />
                <div id="searchResults"></div>
            </div>
            <div id="legend">
                <div class="legend-title">ğŸ® æ“ä½œè¯´æ˜</div>
                <div class="legend-item">ğŸ–±ï¸ æ‹–æ‹½: æ—‹è½¬åœ°çƒ</div>
                <div class="legend-item">ğŸ–±ï¸ æ»šè½®: ç¼©æ”¾è§†å›¾</div>
                <div class="legend-item">ğŸ–±ï¸ æ‚¬åœ: æŸ¥çœ‹ä¿¡æ¯</div>
                <div class="legend-item">ğŸ‘† ç‚¹å‡»: é€‰æ‹©è¿çº¿</div>
                <div class="legend-item">ğŸ‘† åŒå‡»çº¿: æ·»åŠ æ ‡æ³¨</div>
            </div>
            <div id="rotation-info">
                <span class="status-indicator"></span>
                <span id="rotation-status">æ—‹è½¬å·²æš‚åœ</span>
            </div>
            <div id="layer-panel">
                <div class="panel-title">
                    ğŸ“š å›¾å±‚ç®¡ç†
                </div>
                
                <div class="layer-category">
                    <div class="category-header">ğŸ—ºï¸ å›½å®¶è¾¹ç•Œ (Admin 0)</div>
                    <div class="layer-item">
                        <input type="checkbox" class="layer-checkbox" id="layer-countries" data-layer="countries">
                        <label class="layer-label" for="layer-countries">Countries (ä¸»è¦å›½å®¶)</label>
                        <span class="layer-status" id="status-countries">æœªåŠ è½½</span>
                        <input type="file" id="file-countries" accept=".geojson,.json,.shp,.zip" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('file-countries').click()">ğŸ“</button>
                    </div>
                    <div class="layer-item">
                        <input type="checkbox" class="layer-checkbox" id="layer-countries-no-lakes" data-layer="countries-no-lakes">
                        <label class="layer-label" for="layer-countries-no-lakes">Countries (æ— è¾¹ç•Œæ¹–)</label>
                        <span class="layer-status" id="status-countries-no-lakes">æœªåŠ è½½</span>
                        <input type="file" id="file-countries-no-lakes" accept=".geojson,.json,.shp,.zip" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('file-countries-no-lakes').click()">ğŸ“</button>
                    </div>
                    <div class="layer-item">
                        <input type="checkbox" class="layer-checkbox" id="layer-sovereignty" data-layer="sovereignty">
                        <label class="layer-label" for="layer-sovereignty">Sovereignty (ä¸»æƒå›½)</label>
                        <span class="layer-status" id="status-sovereignty">æœªåŠ è½½</span>
                        <input type="file" id="file-sovereignty" accept=".geojson,.json,.shp,.zip" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('file-sovereignty').click()">ğŸ“</button>
                    </div>
                    <div class="layer-item">
                        <input type="checkbox" class="layer-checkbox" id="layer-map-units" data-layer="map-units">
                        <label class="layer-label" for="layer-map-units">Map Units (åœ°å›¾å•å…ƒ)</label>
                        <span class="layer-status" id="status-map-units">æœªåŠ è½½</span>
                        <input type="file" id="file-map-units" accept=".geojson,.json,.shp,.zip" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('file-map-units').click()">ğŸ“</button>
                    </div>
                </div>
                
                <div class="layer-category">
                    <div class="category-header">ğŸ“ è¾¹ç•Œçº¿ (Boundaries)</div>
                    <div class="layer-item">
                        <input type="checkbox" class="layer-checkbox" id="layer-boundaries" data-layer="boundaries">
                        <label class="layer-label" for="layer-boundaries">Country Boundaries</label>
                        <span class="layer-status" id="status-boundaries">æœªåŠ è½½</span>
                        <input type="file" id="file-boundaries" accept=".geojson,.json,.shp,.zip" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('file-boundaries').click()">ğŸ“</button>
                    </div>
                    <div class="layer-item">
                        <input type="checkbox" class="layer-checkbox" id="layer-pacific" data-layer="pacific">
                        <label class="layer-label" for="layer-pacific">Pacific Grouping</label>
                        <span class="layer-status" id="status-pacific">æœªåŠ è½½</span>
                        <input type="file" id="file-pacific" accept=".geojson,.json,.shp,.zip" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('file-pacific').click()">ğŸ“</button>
                    </div>
                </div>
                
                <div class="layer-category">
                    <div class="category-header">ğŸ›ï¸ å·/çœ (Admin 1)</div>
                    <div class="layer-item">
                        <input type="checkbox" class="layer-checkbox" id="layer-states" data-layer="states">
                        <label class="layer-label" for="layer-states">States & Provinces</label>
                        <span class="layer-status" id="status-states">æœªåŠ è½½</span>
                        <input type="file" id="file-states" accept=".geojson,.json,.shp,.zip" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('file-states').click()">ğŸ“</button>
                    </div>
                    <div class="layer-item">
                        <input type="checkbox" class="layer-checkbox" id="layer-states-no-lakes" data-layer="states-no-lakes">
                        <label class="layer-label" for="layer-states-no-lakes">States (æ— å¤§æ¹–)</label>
                        <span class="layer-status" id="status-states-no-lakes">æœªåŠ è½½</span>
                        <input type="file" id="file-states-no-lakes" accept=".geojson,.json,.shp,.zip" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('file-states-no-lakes').click()">ğŸ“</button>
                    </div>
                    <div class="layer-item">
                        <input type="checkbox" class="layer-checkbox" id="layer-state-boundaries" data-layer="state-boundaries">
                        <label class="layer-label" for="layer-state-boundaries">State Boundaries</label>
                        <span class="layer-status" id="status-state-boundaries">æœªåŠ è½½</span>
                        <input type="file" id="file-state-boundaries" accept=".geojson,.json,.shp,.zip" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('file-state-boundaries').click()">ğŸ“</button>
                    </div>
                </div>
                
                <div class="layer-category">
                    <div class="category-header">ğŸ™ï¸ åŸå¸‚ (Populated Places)</div>
                    <div class="layer-item">
                        <input type="checkbox" class="layer-checkbox" id="layer-cities" data-layer="cities">
                        <label class="layer-label" for="layer-cities">Populated Places</label>
                        <span class="layer-status" id="status-cities">æœªåŠ è½½</span>
                        <input type="file" id="file-cities" accept=".geojson,.json,.shp,.zip" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('file-cities').click()">ğŸ“</button>
                    </div>
                    <div class="layer-item">
                        <input type="checkbox" class="layer-checkbox" id="layer-cities-simple" data-layer="cities-simple">
                        <label class="layer-label" for="layer-cities-simple">Cities (ç®€åŒ–ç‰ˆ)</label>
                        <span class="layer-status" id="status-cities-simple">æœªåŠ è½½</span>
                        <input type="file" id="file-cities-simple" accept=".geojson,.json,.shp,.zip" style="display:none">
                        <button class="file-upload-btn" onclick="document.getElementById('file-cities-simple').click()">ğŸ“</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const svg = d3.select("#globe");
        const globeContainer = document.getElementById('globe-container');
        let width, height, initialScale;

        const defs = svg.append("defs");
        const oceanGradient = defs.append("radialGradient")
            .attr("id", "ocean-gradient");
        oceanGradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", "#1a3d5c");
        oceanGradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", "#0a1929");
        
        const projection = d3.geoOrthographic()
            .rotate([0, 0, 0])
            .clipAngle(90);
        
        const path = d3.geoPath().projection(projection);
        const graticule = d3.geoGraticule();
        
        svg.append("path")
            .datum({type: "Sphere"})
            .attr("class", "sphere")
            .attr("d", path);
        
        const layersGroup = svg.append("g").attr("id", "layers");
        const connectionsGroup = svg.append("g").attr("class", "connections");
        
        let graticulePath = layersGroup.append("path")
            .datum(graticule)
            .attr("class", "graticule")
            .attr("d", path);
        
        let showGraticule = true;
        let isRotating = false;
        let rotation = [0, 0];
        
        let selectedPoints = [];
        let connections = [];
        let useParabolicArcs = false;
        let citiesDatabase = null;
        let currentBoundary = null;
        
        // å›¾å±‚æ•°æ®å­˜å‚¨
        const layers = {
            'countries': { data: null, group: null, visible: false, type: 'polygon', pattern: /ne_110m_admin_0_countries\.shp$/ },
            'countries-no-lakes': { data: null, group: null, visible: false, type: 'polygon', pattern: /ne_110m_admin_0_countries_lakes\.shp$/ },
            'sovereignty': { data: null, group: null, visible: false, type: 'polygon', pattern: /ne_110m_admin_0_sovereignty\.shp$/ },
            'map-units': { data: null, group: null, visible: false, type: 'polygon', pattern: /ne_110m_admin_0_map_units\.shp$/ },
            'boundaries': { data: null, group: null, visible: false, type: 'line', pattern: /ne_110m_admin_0_boundary_lines_land\.shp$/ },
            'pacific': { data: null, group: null, visible: false, type: 'line', pattern: /ne_110m_admin_0_pacific_groupings\.shp$/ },
            'states': { data: null, group: null, visible: false, type: 'polygon', pattern: /ne_110m_admin_1_states_provinces\.shp$/ },
            'states-no-lakes': { data: null, group: null, visible: false, type: 'polygon', pattern: /ne_110m_admin_1_states_provinces_lakes\.shp$/ },
            'state-boundaries': { data: null, group: null, visible: false, type: 'line', pattern: /ne_110m_admin_1_states_provinces_lines\.shp$/ },
            'cities': { data: null, group: null, visible: false, type: 'point', pattern: /ne_110m_populated_places\.shp$/ },
            'cities-simple': { data: null, group: null, visible: false, type: 'point', pattern: /ne_110m_populated_places_simple\.shp$/ }
        };
        
        // åˆå§‹åŒ–å›¾å±‚ç»„
        Object.keys(layers).forEach(layerId => {
            layers[layerId].group = layersGroup.append("g")
                .attr("class", `layer-group layer-${layerId}`)
                .style("display", "none");
        });
        
        // åŠ è½½å›¾å±‚æ•°æ®
        function loadLayerData(layerId, file) {
            const fileName = file.name.toLowerCase();
            document.getElementById("info").textContent = `â³ æ­£åœ¨åŠ è½½ ${layerId}...`;
            
            if (fileName.endsWith('.geojson') || fileName.endsWith('.json')) {
                loadGeoJSONLayer(file, layerId);
            } else if (fileName.endsWith('.shp')) {
                loadShapefileLayer(file, layerId);
            } else if (fileName.endsWith('.zip')) {
                loadZipLayer(file, layerId);
            } else {
                alert("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼");
            }
        }
        
        function loadGeoJSONLayer(file, layerId) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const geojson = JSON.parse(e.target.result);
                    processLayerData(layerId, geojson);
                } catch (error) {
                    console.error("GeoJSON è§£æé”™è¯¯:", error);
                    alert(`${layerId} æ–‡ä»¶è§£æå¤±è´¥: ` + error.message);
                }
            };
            reader.readAsText(file);
        }
        
        function loadShapefileLayer(file, layerId) {
            const reader = new FileReader();
            reader.onload = function(e) {
                shapefile.open(e.target.result)
                    .then(source => {
                        const features = [];
                        function readNext() {
                            return source.read().then(result => {
                                if (result.done) return features;
                                features.push(result.value);
                                return readNext();
                            });
                        }
                        return readNext();
                    })
                    .then(features => {
                        const geojson = { type: "FeatureCollection", features: features };
                        processLayerData(layerId, geojson);
                    })
                    .catch(error => {
                        console.error("Shapefile è§£æé”™è¯¯:", error);
                        alert(`${layerId} Shapefile è§£æå¤±è´¥: ` + error.message);
                    });
            };
            reader.readAsArrayBuffer(file);
        }
        
        function loadZipLayer(file, layerId) {
            const reader = new FileReader();
            reader.onload = function(e) {
                shapefile.open(e.target.result)
                    .then(source => {
                        const features = [];
                        function readNext() {
                            return source.read().then(result => {
                                if (result.done) return features;
                                features.push(result.value);
                                return readNext();
                            });
                        }
                        return readNext();
                    })
                    .then(features => {
                        const geojson = { type: "FeatureCollection", features: features };
                        processLayerData(layerId, geojson);
                    })
                    .catch(error => {
                        console.error("ZIP è§£æé”™è¯¯:", error);
                        alert(`${layerId} ZIP è§£æå¤±è´¥: ` + error.message);
                    });
            };
            reader.readAsArrayBuffer(file);
        }
        
        function processLayerData(layerId, geojson) {
            layers[layerId].data = geojson;
            document.getElementById(`status-${layerId}`).textContent = `âœ“ ${geojson.features.length}`;
            document.getElementById(`status-${layerId}`).classList.add('loaded');
            document.getElementById("info").textContent = 
                `âœ… ${layerId} å·²åŠ è½½ (${geojson.features.length} ä¸ªè¦ç´ )`;
            
            renderLayer(layerId);
        }
        
        // åŠ è½½ Cultural Pack (ZIPåŒ…)
        function loadCulturalPack(file) {
            document.getElementById("info").textContent = "â³ æ­£åœ¨è§£æ Cultural Pack...";
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const arrayBuffer = e.target.result;
                
                if (typeof JSZip === 'undefined' || typeof shapefile === 'undefined') {
                    alert("æ‰€éœ€åº“ï¼ˆJSZip, Shapefileï¼‰æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ã€‚");
                    return;
                }
                
                JSZip.loadAsync(arrayBuffer).then(function(zip) {
                    // æ‰¾åˆ°æ‰€æœ‰ .shp æ–‡ä»¶
                    const shpFiles = Object.keys(zip.files).filter(name => 
                        name.endsWith('.shp') && !zip.files[name].dir
                    );
                    
                    console.log("ZIPåŒ…ä¸­æ‰€æœ‰æ–‡ä»¶:", Object.keys(zip.files));
                    console.log("æ‰¾åˆ°çš„SHPæ–‡ä»¶:", shpFiles);
                    
                    if (shpFiles.length === 0) {
                        alert("Cultural Pack ä¸­æœªæ‰¾åˆ° .shp æ–‡ä»¶ã€‚");
                        document.getElementById("info").textContent = "âŒ æœªæ‰¾åˆ° Shapefile";
                        return;
                    }

                    console.log("æ‰¾åˆ°çš„ Shapefile:", shpFiles);
                    document.getElementById("info").textContent = 
                        `â³ æ‰¾åˆ° ${shpFiles.length} ä¸ª Shapefileï¼Œæ­£åœ¨åŠ è½½...`;
                    
                    let loadedCount = 0;
                    let totalFiles = 0;
                    
                    // éå†æ¯ä¸ª shapefile
                    const loadPromises = shpFiles.map(shpFilename => {
                        // åŒ¹é…å¯¹åº”çš„å›¾å±‚
                        let matchedLayerId = null;
                        for (const layerId in layers) {
                            if (layers[layerId].pattern && layers[layerId].pattern.test(shpFilename)) {
                                matchedLayerId = layerId;
                                break;
                            }
                        }
                        
                        console.log(`æ–‡ä»¶ ${shpFilename} åŒ¹é…ç»“æœ:`, matchedLayerId || "æœªåŒ¹é…");
                        
                        if (!matchedLayerId) {
                            console.log(`è·³è¿‡æœªåŒ¹é…çš„æ–‡ä»¶: ${shpFilename}`);
                            return Promise.resolve();
                        }
                        
                        totalFiles++;
                        console.log(`åŒ¹é…åˆ°å›¾å±‚: ${shpFilename} -> ${matchedLayerId}`);
                        
                        // è·å– shapefile çš„æ‰€æœ‰ç›¸å…³æ–‡ä»¶ (.shp, .dbf, .shx, .prj ç­‰)
                        const baseName = shpFilename.replace(/\.shp$/, '');
                        const relatedFiles = Object.keys(zip.files).filter(name => 
                            name.startsWith(baseName) && !zip.files[name].dir
                        );
                        
                        // åˆ›å»ºå­ ZIP åŒ…å«æ‰€æœ‰ç›¸å…³æ–‡ä»¶
                        const subZip = new JSZip();
                        const filePromises = relatedFiles.map(filename => {
                            return zip.files[filename].async("arraybuffer").then(content => {
                                // åªä¿ç•™æ–‡ä»¶åï¼Œå»æ‰è·¯å¾„
                                const shortName = filename.split('/').pop();
                                subZip.file(shortName, content);
                            });
                        });
                        
                        return Promise.all(filePromises)
                            .then(() => subZip.generateAsync({type: "arraybuffer"}))
                            .then(subZipBuffer => {
                                // è§£æ shapefile
                                return shapefile.open(subZipBuffer)
                                    .then(source => {
                                        const features = [];
                                        function readNext() {
                                            return source.read().then(result => {
                                                if (result.done) return features;
                                                features.push(result.value);
                                                return readNext();
                                            });
                                        }
                                        return readNext();
                                    })
                                    .then(features => {
                                        const geojson = { 
                                            type: "FeatureCollection", 
                                            features: features 
                                        };
                                        
                                        // åŠ è½½åˆ°å¯¹åº”å›¾å±‚
                                        processLayerData(matchedLayerId, geojson);
                                        loadedCount++;
                                        
                                        document.getElementById("info").textContent = 
                                            `âœ… å·²åŠ è½½ ${loadedCount}/${totalFiles} ä¸ªå›¾å±‚ (${matchedLayerId}: ${features.length} è¦ç´ )`;
                                        
                                        return { layerId: matchedLayerId, count: features.length };
                                    });
                            })
                            .catch(error => {
                                console.error(`åŠ è½½ ${shpFilename} å¤±è´¥:`, error);
                                return null;
                            });
                    });

                    Promise.all(loadPromises).then(results => {
                        const successful = results.filter(r => r !== null && r !== undefined);
                        if (successful.length > 0) {
                            document.getElementById("info").textContent = 
                                `âœ… Cultural Pack åŠ è½½å®Œæˆï¼æˆåŠŸåŠ è½½ ${successful.length} ä¸ªå›¾å±‚`;
                            
                            // è‡ªåŠ¨å¯ç”¨ä¸»è¦å›¾å±‚
                            if (layers['countries'].data) {
                                document.getElementById('layer-countries').checked = true;
                                toggleLayer('countries', true);
                            }
                        } else {
                            document.getElementById("info").textContent = 
                                `âš ï¸ æœªèƒ½ä» Cultural Pack ä¸­åŠ è½½ä»»ä½•å›¾å±‚`;
                        }
                    });

                }).catch(function(error) {
                    console.error("è§£æ ZIP åŒ…é”™è¯¯:", error);
                    alert("è§£æ Cultural Pack å¤±è´¥: " + error.message);
                    document.getElementById("info").textContent = "âŒ Cultural Pack è§£æå¤±è´¥";
                });
            };
            
            reader.onerror = function() {
                alert("Cultural Pack æ–‡ä»¶è¯»å–é”™è¯¯");
                document.getElementById("info").textContent = "âŒ æ–‡ä»¶è¯»å–é”™è¯¯";
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        function renderLayer(layerId) {
            const layer = layers[layerId];
            if (!layer.data) return;
            
            layer.group.selectAll("*").remove();
            
            if (layer.type === 'polygon') {
                layer.group.selectAll("path")
                    .data(layer.data.features)
                    .enter()
                    .append("path")
                    .attr("class", "layer-country")
                    .attr("d", path)
                    .on("click", function(event, d) {
                        event.stopPropagation();
                        const centroid = d3.geoCentroid(d);
                        handleFeatureClick(centroid, d);
                    })
                    .on("mouseover", function(event, d) {
                        showTooltip(event, d);
                    })
                    .on("mousemove", function(event) {
                        moveTooltip(event);
                    })
                    .on("mouseout", function() {
                        hideTooltip();
                    });
            } else if (layer.type === 'line') {
                layer.group.selectAll("path")
                    .data(layer.data.features)
                    .enter()
                    .append("path")
                    .attr("class", "layer-boundary")
                    .attr("d", path);
            } else if (layer.type === 'point') {
                layer.group.selectAll("circle")
                    .data(layer.data.features)
                    .enter()
                    .append("circle")
                    .attr("class", "layer-city")
                    .attr("r", d => {
                        const pop = d.properties.POP_MAX || d.properties.pop_max || 0;
                        return Math.max(2, Math.min(8, Math.log(pop) / 2));
                    })
                    .attr("transform", d => {
                        const coords = d.geometry.coordinates;
                        const projected = projection(coords);
                        return projected ? `translate(${projected[0]},${projected[1]})` : null;
                    })
                    .on("mouseover", function(event, d) {
                        showTooltip(event, d);
                    })
                    .on("mousemove", function(event) {
                        moveTooltip(event);
                    })
                    .on("mouseout", function() {
                        hideTooltip();
                    })
                    .on("click", function(event, d) {
                        event.stopPropagation();
                        const coords = d.geometry.coordinates;
                        handleFeatureClick(coords, d);
                    });
            }
        }
        
        function handleFeatureClick(centroid, feature) {
            if (selectedPoints.length === 0) {
                selectedPoints.push(centroid);
                const name = getFeatureName(feature);
                document.getElementById("info").textContent = `âœ… å·²é€‰æ‹©èµ·ç‚¹: ${name}`;
            } else if (selectedPoints.length === 1) {
                selectedPoints.push(centroid);
                const name = getFeatureName(feature);
                document.getElementById("info").textContent = `âœ… å·²åˆ›å»ºè¿æ¥çº¿åˆ°: ${name}`;
                drawConnection(selectedPoints[0], selectedPoints[1]);
                selectedPoints = [];
            }
        }
        
        function getFeatureName(feature) {
            return feature.properties.NAME || 
                   feature.properties.name || 
                   feature.properties.ADMIN || 
                   feature.properties.admin ||
                   feature.properties.NAME_EN ||
                   feature.properties.NAME_LONG ||
                   "æœªçŸ¥";
        }
        
        function showTooltip(event, feature) {
            const name = getFeatureName(feature);
            const props = feature.properties;
            let info = `<strong>${name}</strong>`;
            
            if (props.POP_MAX || props.pop_max) {
                info += `<br>äººå£: ${(props.POP_MAX || props.pop_max).toLocaleString()}`;
            }
            if (props.ISO_A2 || props.iso_a2) {
                info += `<br>ä»£ç : ${props.ISO_A2 || props.iso_a2}`;
            }
            
            tooltip.style("display", "block").html(info);
        }
        
        function moveTooltip(event) {
            tooltip
                .style("left", (event.pageX + 15) + "px")
                .style("top", (event.pageY - 10) + "px");
        }
        
        function hideTooltip() {
            tooltip.style("display", "none");
        }
        
        function toggleLayer(layerId, visible) {
            layers[layerId].visible = visible;
            layers[layerId].group.style("display", visible ? "block" : "none");
            
            if (visible && !layers[layerId].data) {
                document.getElementById("info").textContent = `âš ï¸ è¯·å…ˆåŠ è½½ ${layerId} æ•°æ®`;
            }
        }
        
        function updateAllLayers() {
            Object.keys(layers).forEach(layerId => {
                if (layers[layerId].visible && layers[layerId].data) {
                    layers[layerId].group.selectAll("path").attr("d", path);
                    
                    if (layers[layerId].type === 'point') {
                        layers[layerId].group.selectAll("circle")
                            .attr("transform", d => {
                                const coords = d.geometry.coordinates;
                                const projected = projection(coords);
                                return projected ? `translate(${projected[0]},${projected[1]})` : null;
                            })
                            .style("display", d => {
                                const coords = d.geometry.coordinates;
                                const center = [-projection.rotate()[0], -projection.rotate()[1]];
                                return d3.geoDistance(coords, center) < Math.PI / 2 ? "block" : "none";
                            });
                    }
                }
            });
        }
        
        function drawConnection(point1, point2) {
            let pathData;
            
            if (useParabolicArcs) {
                const interpolate = d3.geoInterpolate(point1, point2);
                const midPoint = interpolate(0.5);
                const distance = d3.geoDistance(point1, point2);
                const arcHeight = distance * 0.3;
                const controlLat = midPoint[1] + arcHeight * 50;
                const controlPoint = [midPoint[0], Math.min(90, Math.max(-90, controlLat))];
                
                const points = [];
                for (let i = 0; i <= 50; i++) {
                    const t = i / 50;
                    const t2 = 1 - t;
                    const lon = t2 * t2 * point1[0] + 2 * t2 * t * controlPoint[0] + t * t * point2[0];
                    const lat = t2 * t2 * point1[1] + 2 * t2 * t * controlPoint[1] + t * t * point2[1];
                    points.push([lon, lat]);
                }
                pathData = { type: "LineString", coordinates: points };
            } else {
                const interpolate = d3.geoInterpolate(point1, point2);
                const points = [];
                for (let i = 0; i <= 100; i++) {
                    points.push(interpolate(i / 100));
                }
                pathData = { type: "LineString", coordinates: points };
            }
            
            const currentLineWidth = document.getElementById("lineWidthSlider").value;
            const midPoint = d3.geoInterpolate(point1, point2)(0.5);
            const connectionGroup = connectionsGroup.append("g").attr("class", "connection-group");

            const arcPath = connectionGroup.append("path")
                .datum(pathData)
                .attr("class", "connection-arc")
                .attr("d", path)
                .style("stroke-width", `${currentLineWidth}px`);
            
            const center = [-projection.rotate()[0], -projection.rotate()[1]];
            const isVisible1 = d3.geoDistance(point1, center) < Math.PI / 2;
            const p1 = projection(point1);
            connectionGroup.append("circle")
                .datum({type: "Point", coordinates: point1})
                .attr("class", "connection-point")
                .attr("cx", p1 ? p1[0] : -999)
                .attr("cy", p1 ? p1[1] : -999)
                .attr("r", 5)
                .style("display", isVisible1 ? "block" : "none");

            const isVisible2 = d3.geoDistance(point2, center) < Math.PI / 2;
            const p2 = projection(point2);
            connectionGroup.append("circle")
                .datum({type: "Point", coordinates: point2})
                .attr("class", "connection-point")
                .attr("cx", p2 ? p2[0] : -999)
                .attr("cy", p2 ? p2[1] : -999)
                .attr("r", 5)
                .style("display", isVisible2 ? "block" : "none");
            
            const labelGroup = connectionGroup.append("g")
                .attr("class", "label-group")
                .datum({type: "Point", coordinates: midPoint});
            
            const labelBg = labelGroup.append("rect")
                .attr("class", "connection-label-bg")
                .style("display", "none");
            
            const labelText = labelGroup.append("text")
                .attr("class", "connection-label")
                .style("display", "none");
            
            const connectionData = {
                point1, point2, pathData, midPoint,
                group: connectionGroup,
                labelText: "",
                labelGroup: labelGroup,
                labelBg: labelBg,
                labelTextElement: labelText
            };
            connections.push(connectionData);
            
            arcPath.on("dblclick", function(event) {
                event.stopPropagation();
                showLabelEditor(connectionData, event);
            });
            
            updateConnectionLabel(connectionData);
        }
        
        function showLabelEditor(connectionData, event) {
            const midProj = projection(connectionData.midPoint);
            if (!midProj) return;
            
            const input = document.createElement("input");
            input.className = "label-input";
            input.type = "text";
            input.value = connectionData.labelText || "";
            input.style.left = (midProj[0] - 75) + "px";
            input.style.top = (midProj[1] - 15) + "px";
            
            document.getElementById("map-container").appendChild(input);
            input.focus();
            input.select();
            
            const finishEdit = () => {
                connectionData.labelText = input.value;
                updateConnectionLabel(connectionData);
                input.remove();
            };
            
            input.addEventListener("blur", finishEdit);
            input.addEventListener("keypress", (e) => {
                if (e.key === "Enter") finishEdit();
            });
        }
        
        function updateConnectionLabel(connectionData) {
            const midProj = projection(connectionData.midPoint);
            const center = [-projection.rotate()[0], -projection.rotate()[1]];
            const isVisible = midProj && d3.geoDistance(connectionData.midPoint, center) < Math.PI / 2;
            
            if (connectionData.labelText && isVisible) {
                connectionData.labelTextElement
                    .attr("x", midProj[0])
                    .attr("y", midProj[1] + 5)
                    .text(connectionData.labelText)
                    .style("display", "block");
                
                const bbox = connectionData.labelTextElement.node().getBBox();
                connectionData.labelBg
                    .attr("x", bbox.x - 6)
                    .attr("y", bbox.y - 3)
                    .attr("width", bbox.width + 12)
                    .attr("height", bbox.height + 6)
                    .style("display", "block");
            } else {
                connectionData.labelTextElement.style("display", "none");
                connectionData.labelBg.style("display", "none");
            }
        }
        
        function updateConnections() {
            connections.forEach(conn => {
                conn.group.select(".connection-arc").attr("d", path);
                
                const center = [-projection.rotate()[0], -projection.rotate()[1]];
                
                const point1Data = conn.group.selectAll("circle").filter((d, i) => i === 0).datum();
                const isVisible1 = d3.geoDistance(point1Data.coordinates, center) < Math.PI / 2;
                if (isVisible1) {
                    const p1 = projection(point1Data.coordinates);
                    conn.group.selectAll("circle").filter((d, i) => i === 0)
                        .attr("cx", p1[0]).attr("cy", p1[1]).style("display", "block");
                } else {
                    conn.group.selectAll("circle").filter((d, i) => i === 0).style("display", "none");
                }
                
                const point2Data = conn.group.selectAll("circle").filter((d, i) => i === 1).datum();
                const isVisible2 = d3.geoDistance(point2Data.coordinates, center) < Math.PI / 2;
                if (isVisible2) {
                    const p2 = projection(point2Data.coordinates);
                    conn.group.selectAll("circle").filter((d, i) => i === 1)
                        .attr("cx", p2[0]).attr("cy", p2[1]).style("display", "block");
                } else {
                    conn.group.selectAll("circle").filter((d, i) => i === 1).style("display", "none");
                }
                
                updateConnectionLabel(conn);
            });
        }
        
        function clearConnections() {
            connectionsGroup.selectAll("*").remove();
            connections = [];
            selectedPoints = [];
        }
        
        function loadCitiesDatabase(file) {
            document.getElementById("info").textContent = "â³ æ­£åœ¨åŠ è½½åŸå¸‚æ•°æ®åº“...";
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    citiesDatabase = JSON.parse(e.target.result);
                    document.getElementById("info").textContent = 
                        `âœ… åŸå¸‚æ•°æ®åº“å·²åŠ è½½ (${citiesDatabase.length} ä¸ªå›½å®¶)`;
                    document.getElementById("search-panel").classList.add("active");
                } catch (error) {
                    alert("åŸå¸‚æ•°æ®åº“è§£æå¤±è´¥: " + error.message);
                }
            };
            reader.readAsText(file);
        }
        
        function searchLocation(query) {
            if (!citiesDatabase || !query) {
                document.getElementById("searchResults").innerHTML = "";
                return;
            }
            
            const results = [];
            const lowerQuery = query.toLowerCase();
            
            citiesDatabase.forEach(country => {
                if (country.name && country.name.toLowerCase().includes(lowerQuery)) {
                    results.push({
                        type: 'country', name: country.name,
                        lat: country.latitude, lon: country.longitude,
                        path: country.name, data: country
                    });
                }
                
                if (country.states) {
                    country.states.forEach(state => {
                        if (state.name && state.name.toLowerCase().includes(lowerQuery)) {
                            results.push({
                                type: 'state', name: state.name,
                                lat: state.latitude, lon: state.longitude,
                                path: `${state.name}, ${country.name}`,
                                data: state, country: country
                            });
                        }
                        
                        if (state.cities) {
                            state.cities.forEach(city => {
                                if (city.name && city.name.toLowerCase().includes(lowerQuery)) {
                                    results.push({
                                        type: 'city', name: city.name,
                                        lat: city.latitude, lon: city.longitude,
                                        path: `${city.name}, ${state.name}, ${country.name}`,
                                        data: city, state: state, country: country
                                    });
                                }
                            });
                        }
                    });
                }
            });
            
            displaySearchResults(results.slice(0, 20));
        }
        
        function displaySearchResults(results) {
            const resultsContainer = document.getElementById("searchResults");
            
            if (results.length === 0) {
                resultsContainer.innerHTML = '<div style="color: #88ddff; padding: 10px;">æœªæ‰¾åˆ°åŒ¹é…ç»“æœ</div>';
                return;
            }
            
            resultsContainer.innerHTML = results.map((result, index) => `
                <div class="search-result-item" data-index="${index}">
                    <div class="result-name">${result.name}</div>
                    <div class="result-path">${result.path}</div>
                </div>
            `).join('');
            
            resultsContainer.querySelectorAll('.search-result-item').forEach((item, index) => {
                item.addEventListener('click', () => selectSearchResult(results[index]));
            });
        }
        
        function selectSearchResult(result) {
            if (currentBoundary) {
                currentBoundary.remove();
                currentBoundary = null;
            }
            
            const targetRotation = [-result.lon, -result.lat];
            
            d3.transition().duration(1500)
                .tween("rotate", function() {
                    const r = d3.interpolate(projection.rotate(), targetRotation);
                    return function(t) {
                        projection.rotate(r(t));
                        rotation = projection.rotate();
                        svg.selectAll(".sphere, .graticule").attr("d", path);
                        updateAllLayers();
                        updateConnections();
                    };
                });
            
            setTimeout(() => highlightBoundary(result), 1500);
            document.getElementById("info").textContent = `ğŸ“ å·²å®šä½åˆ°: ${result.path}`;
        }
        
        function highlightBoundary(result) {
            Object.keys(layers).forEach(layerId => {
                if (!layers[layerId].data || layers[layerId].type !== 'polygon') return;
                
                const searchNames = [result.name, result.data.name, result.data.iso2, result.data.iso3].filter(Boolean);
                
                layers[layerId].data.features.forEach(feature => {
                    const featureNames = [
                        feature.properties.NAME, feature.properties.name,
                        feature.properties.ADMIN, feature.properties.admin,
                        feature.properties.NAME_LONG, feature.properties.ISO_A2, feature.properties.ISO_A3
                    ].filter(Boolean);
                    
                    if (searchNames.some(sn => featureNames.some(fn => fn.toLowerCase() === sn.toLowerCase()))) {
                        currentBoundary = layersGroup.append("path")
                            .datum(feature)
                            .attr("class", "boundary-highlight")
                            .attr("d", path);
                    }
                });
            });
        }
        
        function toggleArcMode() {
            useParabolicArcs = !useParabolicArcs;
            document.getElementById("toggleArcMode").textContent = useParabolicArcs ? "ğŸŒ åˆ‡æ¢å¤§åœ†å¼§" : "ğŸŒˆ åˆ‡æ¢æŠ›ç‰©çº¿";
            
            if (connections.length > 0) {
                const existingConnections = connections.map(c => ({
                    point1: c.point1, point2: c.point2, labelText: c.labelText
                }));
                clearConnections();
                existingConnections.forEach(conn => {
                    drawConnection(conn.point1, conn.point2);
                    if (conn.labelText) {
                        connections[connections.length - 1].labelText = conn.labelText;
                        updateConnectionLabel(connections[connections.length - 1]);
                    }
                });
            }
            
            document.getElementById("info").textContent = 
                `ğŸŒˆ å·²åˆ‡æ¢åˆ°${useParabolicArcs ? "æŠ›ç‰©çº¿" : "å¤§åœ†å¼§"}æ¨¡å¼`;
        }
        
        const rotationSpeed = 0.3;
        d3.timer(function(elapsed) {
            if (isRotating) {
                rotation[0] = (rotation[0] + rotationSpeed) % 360;
                projection.rotate(rotation);
                svg.selectAll(".sphere, .graticule").attr("d", path);
                updateAllLayers();
                updateConnections();
            }
        });
        
        const drag = d3.drag()
            .on("start", function() {
                isRotating = false;
                updateRotationStatus();
            })
            .on("drag", function(event) {
                const rotate = projection.rotate();
                const k = 75 / projection.scale();
                projection.rotate([rotate[0] + event.dx * k, rotate[1] - event.dy * k]);
                rotation = projection.rotate();
                svg.selectAll(".sphere, .graticule").attr("d", path);
                updateAllLayers();
                updateConnections();
            });
        
        svg.call(drag);
        
        const zoom = d3.zoom()
            .scaleExtent([0.5, 20])
            .on("zoom", function(event) {
                if (!initialScale) return;
                projection.scale(initialScale * event.transform.k);
                svg.selectAll(".sphere, .graticule").attr("d", path);
                updateAllLayers();
                updateConnections();
            });
        
        svg.call(zoom);
        
        const tooltip = d3.select("#tooltip");
        
        // äº‹ä»¶ç›‘å¬å™¨
        document.getElementById("culturalPackInput").addEventListener("change", function(e) {
            const file = e.target.files[0];
            if (file) {
                console.log("åŠ è½½ Cultural Pack:", file.name);
                loadCulturalPack(file);
            }
        });
        
        Object.keys(layers).forEach(layerId => {
            document.getElementById(`file-${layerId}`).addEventListener('change', function(e) {
                if (e.target.files[0]) {
                    loadLayerData(layerId, e.target.files[0]);
                }
            });
            
            document.getElementById(`layer-${layerId}`).addEventListener('change', function(e) {
                toggleLayer(layerId, e.target.checked);
            });
        });
        
        document.getElementById("resetBtn").addEventListener("click", function() {
            svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        });
        
        document.getElementById("toggleGraticule").addEventListener("click", function() {
            showGraticule = !showGraticule;
            graticulePath.style("display", showGraticule ? "block" : "none");
        });
        
        document.getElementById("toggleRotation").addEventListener("click", function() {
            isRotating = !isRotating;
            updateRotationStatus();
        });
        
        document.getElementById("clearConnections").addEventListener("click", function() {
            clearConnections();
            document.getElementById("info").textContent = "ğŸ—‘ï¸ å·²æ¸…é™¤æ‰€æœ‰è¿æ¥çº¿";
        });
        
        document.getElementById("toggleArcMode").addEventListener("click", toggleArcMode);
        
        document.getElementById("citiesDbInput").addEventListener("change", function(e) {
            if (e.target.files[0]) loadCitiesDatabase(e.target.files[0]);
        });
        
        document.getElementById("searchInput").addEventListener("input", function(e) {
            searchLocation(e.target.value);
        });
        
        const lineWidthSlider = document.getElementById("lineWidthSlider");
        lineWidthSlider.addEventListener("input", function() {
            const newWidth = this.value;
            document.getElementById("lineWidthValue").textContent = `${newWidth}px`;
            connectionsGroup.selectAll(".connection-arc").style("stroke-width", `${newWidth}px`);
        });
        
        function updateRotationStatus() {
            const btn = document.getElementById("toggleRotation");
            const status = document.getElementById("rotation-status");
            if (isRotating) {
                btn.textContent = "â¸ï¸ æš‚åœæ—‹è½¬";
                status.textContent = "è‡ªåŠ¨æ—‹è½¬ä¸­...";
            } else {
                btn.textContent = "â–¶ï¸ å¼€å§‹æ—‹è½¬";
                status.textContent = "æ—‹è½¬å·²æš‚åœ";
            }
        }
        
        function handleResize() {
            width = globeContainer.clientWidth;
            height = globeContainer.clientHeight;
            svg.attr('width', width).attr('height', height);
            initialScale = Math.min(width, height) / 2.2;
            const currentZoom = d3.zoomTransform(svg.node());
            projection.scale(initialScale * currentZoom.k).translate([width / 2, height / 2]);
            svg.selectAll(".sphere, .graticule").attr("d", path);
            updateAllLayers();
            updateConnections();
        }

        window.addEventListener('resize', handleResize);
        handleResize();
    </script>
</body>
</html>